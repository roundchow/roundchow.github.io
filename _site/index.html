<!DOCTYPE html> <html lang="en" class="no-js"> <head> <meta charset="UTF-8"/> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>圆周博客</title> <meta name="description" content="在世界中心呼唤爱"/> <meta name="keywords" content="周围, Blog, 创意, chow, tech, round, loi, wu"/> <meta name="author" content="Loi"/> <link rel="shortcut icon" href="img/timg01.jpg"> <link rel="stylesheet" type="text/css" href="css/normalize.css"/> <link rel="stylesheet" type="text/css" href="fonts/font-awesome/css/font-awesome.css"/> <link rel="stylesheet" type="text/css" href="css/modern-blog.css"/> <!--[if IE]> <script type="text/javascript" src="js/vendors/html5.min.js"></script> <![endif]--> <script> if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) { var root = document.getElementsByTagName('html')[0]; root.setAttribute('class', 'ff'); } </script> </head> <body class="body"> <div class="container"> <header class="header"> <h1>roundchow Blog<span>圆周博客</span></h1> <!-- <nav class="links"> <a href="https://www.linkedin.com/in/loi-wu-728b4969" target="_blank"><i class="fa fa-linkedin-square fa-3x"></i></a> <a href="https://github.com/loiwu" target="_blank"><i class="fa fa-github-square fa-3x"></i></a> </nav> --> </header> <div class="content"> <!-- trianglify pattern container --> <div class="pattern pattern--hidden"></div> <!-- cards --> <div class="wrapper"> <div class="card" data-id="/2018/10/26/Language"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="/2018/10/26/Language-clip-path"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#/2018/10/26/Language-clip-path)" width="1920" height="1200" xlink:href="img/f.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">λanguage - 如何实现一门编程语言</h2> <p class="card__subtitle">How to implement a programming language in JavaScript</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/tigerCat.jpg"/> <span class="meta__author">wu</span> <span class="meta__date">2018-10-26</span> </div> <p>How to implement a programming language in JavaScript</p> <p>如何用JavaScript实现一门编程语言</p> <h2 id="introduction">Introduction</h2> <p>· Write a parser 编写词法分析器</p> <p>· Write an interpreter 编写解释器</p> <p>· <a href="https://en.wikipedia.org/wiki/Continuation">Continuations 延续</a></p> <p>· Write a compiler 编写编译器</p> <p>· Transform code to continuation-passing style 将代码转换成“连续传递的风格”</p> <p>· Optimization techniques 优化技术</p> <p>· Examples of what λanguage brings new over plain JavaScript λanguage基于JavaScript之上的新特性示例</p> <h2 id="λanguage-description">λanguage description</h2> <p>Before anything, we should have a clear picture about what we’re trying to achieve. 开工之前，我们先要对即将实现的目标有一个清晰的认识。It’s a good idea to put together a rigorous description of the grammar. 接下来，我们把语法严格的描述出来，举个例子：</p><pre>
# this is a comment
println("Hello λanguage!");
println(2 + 3 * 4);
# functions are introduced with `lambda` or `λ`
fib = lambda (n) if n &lt; 2 then n else fib(n - 1) + fib(n - 2);
println(fib(15));
print-range = λ(a, b)             # `λ` is synonym to `lambda`
                if a &lt;= b then {  # `then` here is optional as you can see below
                  print(a);
                  if a + 1 &lt;= b {
                    print(", ");
                    print-range(a + 1, b);
                  } else println("");        # newline
                };
print-range(1, 5);
</pre><p>The output is 输出:</p><pre>
Hello World!
14
610
1, 2, 3, 4, 5
</pre><p>evaluates an expression 计算表达式:</p><pre>
a = {
  fib(10);  # has no side-effects, but it's computed anyway
  fib(15)   # the last semicolon can be missing
};
print(a); # prints 610
</pre><p>ternary operator 三目运算符:</p><pre>
a = foo() ? bar() : baz();           // JavaScript
a = if foo() then bar() else baz();  # λanguage
</pre><p>if expression if表达式:</p><pre>
if foo() then print("It will print "OK" if and only if the result of foo() is NOT false.");
</pre><h2 id="writing-a-parser">Writing a parser</h2> <p>In essence, a parser must transform a piece of code (which we inspect by looking at the characters) into an “abstract syntax tree” (AST). The AST is a structured in-memory representation of the program, and it’s “abstract” in the sense that it does not care exactly what characters is the source code made of, but it faithfully represents the semantics of it. 词法分析器，通过检查每一个字符，解决将代码转换成AST抽象语法树的任务。之所以称之为“抽象”，是因为AST并不关心源代码是由什么字符所组成的，它只是严格的呈现源代码的语义。</p> <p>For example, for the following program text 举个例子，对于以下的程序文本:</p><pre>
sum = lambda(a, b) {
  a + b;
};
print(sum(1, 2));
</pre><p>The parser will generate the following AST, as a JavaScript object: 词法分析器会产生如下的抽象语法树，形如一个JavaScript对象：</p><pre>
{
  type: "prog",
  prog: [
    // first line:
    {
      type: "assign",
      operator: "=",
      left: { type: "var", value: "sum" },
      right: {
        type: "lambda",
        vars: [ "a", "b" ],
        body: {
          // the body should be a "prog", but because
          // it contains a single expression, our parser
          // reduces it to the expression itself.
          type: "binary",
          operator: "+",
          left: { type: "var", value: "a" },
          right: { type: "var", value: "b" }
        }
      }
    },
    // second line:
    {
      type: "call",
      func: { type: "var", value: "print" },
      args: [{
        type: "call",
        func: { type: "var", value: "sum" },
        args: [ { type: "num", value: 1 },
                { type: "num", value: 2 } ]
      }]
    }
  ]
}
</pre><p>The main difficulty in writing a parser consists in a failure to properly organize the code. The parser should operate at a higher level than reading characters from a string. A few advices on how to keep complexity manageable: 编写一个词法解析器解析器的主要困难在于未能恰当地组织代码。词法解析器的运作，应该高于从字符串中读取字符的层面。针对控制词法解析器编写的复杂度程度，以下给出三个建议：</p> <p>· Write many functions and keep them small. In every function, do one thing and do it well. 多写函数并尽量保持单个函数的精简，在每个函数中，一次做好一件事。</p> <p>· Do not try to use regexps for parsing. They don’t work. Regexps can be helpful in the lexer though, but I suggest to limit them to very simple things. 不要在词法分析时使用正则表达式，此时正则不管用。虽然正则有助于词法的分析，但建议在处理简单的事情时，克制对正则的使用。</p> <p>· Don’t attempt to guess. When unsure how to parse something, throw an error and make sure the message contains the error location (line/column). 绝对不要胡乱瞎猜。如果词法分析时遇到了不确定的情况，可以抛出异常，并确保错误信息里包含了异常发生的代码行/列。</p> <h3 id="input-stream---the-character-input-stream-字符输入流">Input stream - The character input stream 字符输入流</h3> <p>This is the smallest part. We’re going to create a “stream object” which provides operations to read characters from a string. 首先编写“流对象”，提供一组操作，从字符串里读取字符。</p> <p>A stream object has 4 methods 流对象包含4种方法:</p> <p>· peek() — returns the next value but without removing it from the stream. 返回下一个值。但不在流中将其去除。</p> <p>· next() — returns the next value and also discards it from the stream. 返回下一个值。同时在流中将其去除。</p> <p>· eof() — returns true if and only if there are no more values in the stream. 返回真，当且仅当流中没有更多值。</p> <p>· croak(msg) — does throw new Error(msg). 抛出异常new Error(msg)，便于追踪和定位发生异常的代码片段。</p> <p>The full code of “InputStream” object: 以下是实现“输入流”对象的完整代码：</p><pre>
function InputStream(input) {
    var pos = 0, line = 1, col = 0;
    return {
        next  : next,
        peek  : peek,
        eof   : eof,
        croak : croak,
    };
    function next() {
        var ch = input.charAt(pos++);
        if (ch == "\n") line++, col = 0; else col++;
        return ch;
    }
    function peek() {
        return input.charAt(pos);
    }
    function eof() {
        return peek() == "";
    }
    function croak(msg) {
        throw new Error(msg + " (" + line + ":" + col + ")");
    }
}
</pre><h3 id="token-stream---the-token-input-stream-分词输入流">Token stream - The token input stream 分词输入流</h3> <p>The tokenizer (also called “lexer”) operates on a character input stream and returns a stream object with the same interface, but the values returned by peek() / next() will be tokens. A token is an object with two properties: type and value. 分词器（或称“词法分析器”）对字符输入流进行操作，并通过相同接口返回对象流。不过对于peek() / next()的处理，仍然返回分词。分词是一种具有type和value两个属性的对象。</p> <p>Here are some examples with supported tokens: 以下示例给出一些支持的分词形式：</p><pre>
{ type: "punc", value: "(" }           // punctuation: parens, comma, semicolon etc.
{ type: "num", value: 5 }              // numbers
{ type: "str", value: "Hello World!" } // strings
{ type: "kw", value: "lambda" }        // keywords
{ type: "var", value: "a" }            // identifiers
{ type: "op", value: "!=" }            // operators
</pre><p>Whitespace and comments are skipped over, no tokens are returned. 空格和注释会被跳过，不返回分词。</p> <p>In order to write the tokenizer we need to look more closely into the syntax of our language. The idea is to notice that depending on the current character (as returned by input.peek()) we can decide what kind of token to read: 为了编写分词器，先对将要实现的编程语言的语法进行仔细的确认。通过input.peek()返回的当前字符，可以确定正在读取什么样的分词：</p> <p>· First off, skip over whitespace. 首先，略去空格。</p> <p>· If input.eof() then return null. 如果遇到input.eof()，则返回null（空）。</p> <p>· If it’s a sharp sign (#), skip comment (retry after the end of line). 如果遇到#，略去注释。在最后一行之后进行重试。</p> <p>· If it’s a quote then read a string. 如果遇到引号quote，就紧接着读取字符串string。</p> <p>· If it’s a digit, then we proceed to read a number. 如果遇到数位digit，就进行数字的读取。</p> <p>· If it’s a “letter”, then read an identifier or a keyword token. 如果遇到字母“letter”，就读取一个标识符或一个关键词分词。</p> <p>· If it’s one of the punctuation characters, return a punctuation token. 如果遇到标点字符，就返回对应的标点分词。</p> <p>· If it’s one of the operator characters, return an operator token. 如果遇到一个运算符字符，就返回对应的运算符分词。</p> <p>· If none of the above, error out with input.croak(). 如果遇到的是非上述的内容，就通过input.croak()抛出异常信息。</p> <p>So here’s the “read_next” function — the “core” of the tokenizer — which implements the above: 以下是函数“read_next”，它是分词器的核心部分，是对上述规则的具体实现：</p><pre>
function read_next() {
    read_while(is_whitespace);
    if (input.eof()) return null;
    var ch = input.peek();
    if (ch == "#") {
        skip_comment();
        return read_next();
    }
    if (ch == '"') return read_string();
    if (is_digit(ch)) return read_number();
    if (is_id_start(ch)) return read_ident();
    if (is_punc(ch)) return {
        type  : "punc",
        value : input.next()
    };
    if (is_op_char(ch)) return {
        type  : "op",
        value : read_while(is_op_char)
    };
    input.croak("Can't handle character: " + ch);
}
</pre><p>This is a “dispatcher” function and it’s what next() will call in order to fetch the next token. Note it uses many utilities that are focused on particular token types, like read_string(), read_number() etc. There’s no point to complicate the dispatcher with code from those functions, even if we never call them elsewhere. 这是一个“调度器（dispatcher）”函数，当next()被调用时触发，以获取下一个分词。注意到它使用了不少工具方法来判断特定的分词类型，比如read_string(), read_number()等。没必要在调度器dispatcher函数里实现这些方法，从而增加代码的复杂度。</p> <p>The code pretty much speaks for itself now, so here is the complete tokenizer for our language. 代码自己会说话，以下是这个新的编程语言完整的分词器的实现：</p><pre>
function TokenStream(input) {
    var current = null;
    var keywords = " if then else lambda λ true false ";
    return {
        next  : next,
        peek  : peek,
        eof   : eof,
        croak : input.croak
    };
    function is_keyword(x) {
        return keywords.indexOf(" " + x + " ") &gt;= 0;
    }
    function is_digit(ch) {
        return /[0-9]/i.test(ch);
    }
    function is_id_start(ch) {
        return /[a-zλ_]/i.test(ch);
    }
    function is_id(ch) {
        return is_id_start(ch) || "?!-&lt;&gt;=0123456789".indexOf(ch) &gt;= 0;
    }
    function is_op_char(ch) {
        return "+-*/%=&amp;|&lt;&gt;!".indexOf(ch) &gt;= 0;
    }
    function is_punc(ch) {
        return ",;(){}[]".indexOf(ch) &gt;= 0;
    }
    function is_whitespace(ch) {
        return " \t\n".indexOf(ch) &gt;= 0;
    }
    function read_while(predicate) {
        var str = "";
        while (!input.eof() &amp;&amp; predicate(input.peek()))
            str += input.next();
        return str;
    }
    function read_number() {
        var has_dot = false;
        var number = read_while(function(ch){
            if (ch == ".") {
                if (has_dot) return false;
                has_dot = true;
                return true;
            }
            return is_digit(ch);
        });
        return { type: "num", value: parseFloat(number) };
    }
    function read_ident() {
        var id = read_while(is_id);
        return {
            type  : is_keyword(id) ? "kw" : "var",
            value : id
        };
    }
    function read_escaped(end) {
        var escaped = false, str = "";
        input.next();
        while (!input.eof()) {
            var ch = input.next();
            if (escaped) {
                str += ch;
                escaped = false;
            } else if (ch == "\\") {
                escaped = true;
            } else if (ch == end) {
                break;
            } else {
                str += ch;
            }
        }
        return str;
    }
    function read_string() {
        return { type: "str", value: read_escaped('"') };
    }
    function skip_comment() {
        read_while(function(ch){ return ch != "\n" });
        input.next();
    }
    function read_next() {
        read_while(is_whitespace);
        if (input.eof()) return null;
        var ch = input.peek();
        if (ch == "#") {
            skip_comment();
            return read_next();
        }
        if (ch == '"') return read_string();
        if (is_digit(ch)) return read_number();
        if (is_id_start(ch)) return read_ident();
        if (is_punc(ch)) return {
            type  : "punc",
            value : input.next()
        };
        if (is_op_char(ch)) return {
            type  : "op",
            value : read_while(is_op_char)
        };
        input.croak("Can't handle character: " + ch);
    }
    function peek() {
        return current || (current = read_next());
    }
    function next() {
        var tok = current;
        current = null;
        return tok || read_next();
    }
    function eof() {
        return peek() == null;
    }
}
</pre><p>· The next() function doesn’t always call read_next(), because it might have been peeked before (in which case read_next() was already called and the stream advanced). Therefore we need a current variable which keeps track of the current token. 函数next()不会每次都调用到read_next()。通过专门的current变量来追踪当前处理的分词。</p> <p>· We only support decimal numbers with the usual notation (no 1E5 stuff, no hex, no octal). But if we ever need more, the changes go only in read_number() and are pretty easy to do. 该编程语言只支持常见十进制数，如果需要支持更多的符号，可以通过完善函数read_number()来实现。</p> <p>· Unlike JavaScript, the only characters that cannot appear unquoted in a string are the quote character itself and the backslash. You need to backslash them. Otherwise strings can contain hard newlines, tabs, and whatnot. We don’t interpret the usual escapes like \n, \t etc. though again, the changes would be pretty trivial (in “read_string”).</p> <h3 id="the-ast">The AST</h3> <p>As mentioned, the parser will build a structure which faithfully represents the semantics of the program. An AST node is a plain JavaScript object that has a type property specifying what kind of node it is, and additional information, depending on the particular type. 词法分析器parser，可以为程序创建一种严格表达语义的结构。一个AST抽象语法树节点是纯JavaScript对象，它拥有一个类型属性以表明节点的类型，并根据不同的节点类型，附加更多的信息。</p><pre>
In short:

    · num { type: "num", value: NUMBER }
    · str { type: "str", value: STRING }
    · bool { type: "bool", value: true or false }
    · var { type: "var", value: NAME }
    · lambda { type: "lambda", vars: [ NAME... ], body: AST }
    · call { type: "call", func: AST, args: [ AST... ] }
    · if { type: "if", cond: AST, then: AST, else: AST }
    · assign { type: "assign", operator: "=", left: AST, right: AST }
    · binary { type: "binary", operator: OPERATOR, left: AST, right: AST }
    · prog { type: "prog", prog: [ AST... ] }
    · let { type: "let", vars: [ VARS... ], body: AST }

</pre><pre>
Examples:

Numbers ("num")
123.5 
-&gt;
{ type: "num", value: 123.5 }

Strings ("str")
"Hello World!"
-&gt;
{ type: "str", value: "Hello World!" }

Booleans ("bool")
true
-&gt;
{ type: "bool", value: true }
false
-&gt;
{ type: "bool", value: false }

Identifiers ("var")
foo
-&gt;
{ type: "var", value: "foo" }

Functions ("lambda")
lambda (x) 10   
# or 
λ (x) 10 
-&gt; 
{
  type: "lambda",
  vars: [ "x" ],
  body: { type: "num", value: 10 }
}

Function calls ("call")
foo(a, 1) 
-&gt;
{
  "type": "call",
  "func": { "type": "var", "value": "foo" },
  "args": [
    { "type": "var", "value": "a" },
    { "type": "num", "value": 1 }
  ]
}

Conditionals ("if") 
if foo then bar else baz 
-&gt;
{
  "type": "if",
  "cond": { "type": "var", "value": "foo" },
  "then": { "type": "var", "value": "bar" },
  "else": { "type": "var", "value": "baz" }
}

The else branch is optional:
if foo then bar 
-&gt;
{
  "type": "if",
  "cond": { "type": "var", "value": "foo" },
  "then": { "type": "var", "value": "bar" }
}

Assignment ("assign")
a = 10 
-&gt;
{
  "type": "assign",
  "operator": "=",
  "left": { "type": "var", "value": "a" },
  "right": { "type": "num", "value": 10 }
}

Binary expressions ("binary")
x + y * z 
-&gt;
{
  "type": "binary",
  "operator": "+",
  "left": { "type": "var", "value": "x" },
  "right": {
    "type": "binary",
    "operator": "*",
    "left": { "type": "var", "value": "y" },
    "right": { "type": "var", "value": "z" }
  }
}

Sequences ("prog")
{
  a = 5;
  b = a * 2;
  a + b;
}
-&gt;
{
  "type": "prog",
  "prog": [
    {
      "type": "assign",
      "operator": "=",
      "left": { "type": "var", "value": "a" },
      "right": { "type": "num", "value": 5 }
    },
    {
      "type": "assign",
      "operator": "=",
      "left": { "type": "var", "value": "b" },
      "right": {
        "type": "binary",
        "operator": "*",
        "left": { "type": "var", "value": "a" },
        "right": { "type": "num", "value": 2 }
      }
    },
    {
      "type": "binary",
      "operator": "+",
      "left": { "type": "var", "value": "a" },
      "right": { "type": "var", "value": "b" }
    }
  ]
}

Block scoped variables ("let")
let (a = 10, b = a * 10) {
  a + b;
}
-&gt;
{
  "type": "let",
  "vars": [
    {
      "name": "a",
      "def": { "type": "num", "value": 10 }
    },
    {
      "name": "b",
      "def": {
        "type": "binary",
        "operator": "*",
        "left": { "type": "var", "value": "a" },
        "right": { "type": "num", "value": 10 }
      }
    }
  ],
  "body": {
    "type": "binary",
    "operator": "+",
    "left": { "type": "var", "value": "a" },
    "right": { "type": "var", "value": "b" }
  }
}


</pre><p>· 以下未完待续</p><pre>

### The parser

## Simple interpreter

### Test what we have

### Adding new constructs

### How fast are we?

## CPS Evaluator

### Guarding the stack

### Continuations

#### Yield (advanced)

## Compiling to JS

### JS code generator

### CPS transformer

#### Samples

#### Improvements

### Optimizer

## Wrapping up

## Real samples

### Primitives

### catDir

### copyTree sequential

### copyTree parallel

### In fairness to Node

### Error handling

</pre><p>· How to implement a programming language in JavaScript - Loi Wu -</p> <div class="scale"><img src="img/hugkiss.jpg" alt="λanguage" /></div> </div> </div> </div> </div> <div class="card" data-id="/2018/10/07/effective-javascript"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="/2018/10/07/effective-javascript-clip-path"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#/2018/10/07/effective-javascript-clip-path)" width="1920" height="1200" xlink:href="img/tigerCat.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">Effective JavaScript</h2> <p class="card__subtitle">提升功力的心法秘籍</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/tigerCat.jpg"/> <span class="meta__author">wu</span> <span class="meta__date">2018-10-07</span> </div> <p>Effective JavaScript</p> <h2 id="1---accustoming-yourself-to-javascript">1 - Accustoming Yourself to JavaScript</h2> <h3 id="item-1-know-which-javascript-you-are-using">Item 1: Know Which JavaScript You Are Using</h3> <p>✦ Decide which versions of JavaScript your application supports.</p> <p>✦ Be sure that any JavaScript features you use are supported by all environments where your application runs.</p> <p>✦ Always test strict code in environments that perform the strict-mode checks.</p> <p>✦ Beware of concatenating scripts that differ in their expectations about strict mode.</p> <h3 id="item-2-understand-javascripts-floating-point-numbers">Item 2: Understand JavaScript’s Floating-Point Numbers</h3> <p>✦ JavaScript numbers are double-precision floating-point numbers.</p> <p>✦ Integers in JavaScript are just a subset of doubles rather than a separate datatype.</p> <p>✦ Bitwise operators treat numbers as if they were 32-bit signed integers.</p> <p>✦ Be aware of limitations of precisions in flaoting-point arithmetic.</p> <h3 id="item-3-beware-of-implicit-coercions">Item 3: Beware of Implicit Coercions</h3> <p>✦ Type errors can be silently hidden by implicit coercions.</p> <p>✦ The + operator is overloaded to do addition or string concatenation depending on its argument types.</p> <p>✦ Objects are coerced to numbers via valueOf and to strings via toString.</p> <p>✦ Objects with valueOf methods should implement a toString method taht provides a string representation of the number produced by valueOf.</p> <p>✦ Use typeof or comparison to undefined rather than truthiness to test for undefined values.</p> <h3 id="item-4-prefer-primitives-to-object-wrappers">Item 4: Prefer Primitives to Object Wrappers</h3> <p>✦ Object wrappers for primitive types do not have the same behavior as their primitive calues when compared for equality.</p> <p>✦ Getting and setting properties on primitives implicitly creates object wrappers.</p> <h3 id="item-5-avoid-using--with-mixed-types">Item 5: Avoid using == with Mixed Types</h3> <p>✦ The == operator applies a confusing set of implicit coercoins when its arguments are of different types.</p> <p>✦ Use === to make it clear to your readers that your comparison does not involve any implicit coercions.</p> <p>✦ Use your own explicit coercions when comparing values of different types to make your program’s behavior clearer.</p> <h3 id="item-6-learn-the-limits-of-semicolon-insertion">Item 6: Learn the Limits of Semicolon Insertion</h3> <p>✦ Semicolons are only ever inferred before a }, at the end of a line, or at the end of a program.</p> <p>✦ Semicolons are only ever inffered when the next token cannot be parsed.</p> <p>✦ Never omit a semicolon before a statement beginning with (, [, +, -, or /.</p> <p>✦ When concatenating scripts, insert semicolons explicitly between scripts.</p> <p>✦ Never put a newline before the argument to return, throw, break, continue, ++, or –.</p> <p>✦ Semicolons are never inferred as separators in the head of a for loop or as empty statements.</p> <h3 id="item-7-think-of-strings-as-sequences-of-16-bit-code-units">Item 7: Think of Strings As Sequences of 16-Bit Code Units</h3> <p>✦ JavaScript strings consist of 16-bit code units, not Unicode code points.</p> <p>✦ Unicode code points 2^16 and above are represented in JavaScript by two code units, known as a surrogate pair.</p> <p>✦ Surrogate pairs throw off string element counts, affecting length, charAt, charCodeAt, and regular expression patterns such as “.”.</p> <p>✦ Use third-party libraries for writing code point-aware string manipulation.</p> <p>✦ Whenever you are using a library that works with strings, consult the documentation to see how it handles the full range of code points.</p> <h2 id="2---variable-scope">2 - Variable Scope</h2> <h3 id="item-8-minimize-use-of-the-global-object">Item 8: Minimize Use of the Global Object</h3> <p>✦ Avoid declaring global variables.</p> <p>✦ Declare variables as locally as possible.</p> <p>✦ Avoid adding properties to the global object.</p> <p>✦ Use the global object for platform feature detection.</p> <h3 id="item-9-always-declare-local-variables">Item 9: Always Declare Local Variables</h3> <p>✦ Always declare new local variables with var.</p> <p>✦ Consider using lint tools to help check for unbound variables.</p> <h3 id="item-10-avoid-with">Item 10: Avoid with</h3> <p>✦ Avoid using with statements.</p> <p>✦ Use short variable names for repeated access to an object.</p> <p>✦ Explicitly bind local variables to object properties instead of implicitly binding them with a with statement.</p> <h3 id="item-11-get-comfortable-with-closures">Item 11: Get Comfortable with Closures</h3> <p>✦ Functions can refer to variables defined in outer scopes.</p> <p>✦ Closures can outlive the function that creates them.</p> <p>✦ Closures internally store references to their outer variables, and can both read and update their stored variables.</p> <h3 id="item-12-understand-variable-hoisting">Item 12: Understand Variable Hoisting</h3> <p>✦ Variable declarations within a block are implicitly hoisted to the top of their enclosing function.</p> <p>✦ Redeclarations of a variable are treated as a single variable.</p> <p>✦ Consider manually hoisting local variable declarations to avoid confusion.</p> <h3 id="item-13-use-immediately-invoked-function-expressions-to-create-local-scopes">Item 13: Use Immediately Invoked Function Expressions to Create Local Scopes</h3> <p>✦ Understand the difference between binding and assignment.</p> <p>✦ Closures capture their outer variables by reference, not by value.</p> <p>✦ Use immediately invoked function expressions (IIFEs) to create local scopes.</p> <p>✦ Be aware of the cases where wrapping a block in an IIFE can change its behavior.</p> <h3 id="item-14-beware-of-unportable-scoping-of-named-function-expressions">Item 14: Beware of Unportable Scoping of Named Function Expressions</h3> <p>✦ Use named function expressions to improve stack traces in Error objects and debuggers.</p> <p>✦ Beware of pollution of function expression scope with Object .prototype in ES3 and buggy JavaScript environments.</p> <p>✦ Beware of hoisting and duplicate allocation of named function expressions in buggy JavaScript environments.</p> <p>✦ Consider avoiding named function expressions or removing them before shipping.</p> <p>✦ If you are shipping in properly implemented ES5 environments, you’ve got nothing to worry about.</p> <h3 id="item-15-beware-of-unportable-scoping-of-block-local-function-declarations">Item 15: Beware of Unportable Scoping of Block-Local Function Declarations</h3> <p>✦ Always keep function declarations at the outermost level of a program or a containing function to avoid unportable behavior.</p> <p>✦ Use var declarations with conditional assignment instead of conditional function declarations.</p> <h3 id="item-16-avoid-creating-local-variables-with-eval">Item 16: Avoid Creating Local Variables with eval</h3> <p>✦ Avoid creating variables with eval that pollute the caller’s scope.</p> <p>✦ If eval code might create global variables, wrap the call in a nested function to prevent scope pollution.</p> <h3 id="item-17-prefer-indirect-eval-to-direct-eval">Item 17: Prefer Indirect eval to Direct eval</h3> <p>✦ Wrap eval in a sequence expression with a useless literal to force the use of indirect eval.</p> <p>✦ Prefer indirect eval to direct eval whenever possible.</p> <h2 id="3---working-with-functions">3 - Working with Functions</h2> <h3 id="item-18-understand-the-difference-between-function-method-and-constructor-calls">Item 18: Understand the Difference between Function, Method, and Constructor Calls</h3> <p>✦ Method calls provide the object in which the method property is looked up as their receiver.</p> <p>✦ Function calls provide the global object (or undefined for strict func- tions) as their receiver. Calling methods with function call syntax is rarely useful.</p> <p>✦ Constructors are called with new and receive a fresh object as their receiver.</p> <h3 id="item-19-get-comfortable-using-higher-order-functions">Item 19: Get Comfortable Using Higher-Order Functions</h3> <p>✦ Higher-order functions are functions that take other functions as arguments or return functions as their result.</p> <p>✦ Familiarize yourself with higher-order functions in existing libraries.</p> <p>✦ Learn to detect common coding patterns that can be replaced by higher-order functions.</p> <h3 id="item-20-use-call-to-call-methods-with-a-custom-receiver">Item 20: Use call to Call Methods with a Custom Receiver</h3> <p>✦ Use the call method to call a function with a custom receiver.</p> <p>✦ Use the call method for calling methods that may not exist on a given object.</p> <p>✦ Use the call method for defining higher-order functions that allow clients to provide a receiver for the callback.</p> <h3 id="item-21-use-apply-to-call-functions-with-different-numbers-of-arguments">Item 21: Use apply to Call Functions with Different Numbers of Arguments</h3> <p>✦ Use the apply method to call variadic functions with a computed array of arguments.</p> <p>✦ Use the first argument of apply to provide a receiver for variadic methods.</p> <h3 id="item-22-use-arguments-to-create-variadic-functions">Item 22: Use arguments to Create Variadic Functions</h3> <p>✦ Use the implicit arguments object to implement variable-arity functions.</p> <p>✦ Consider providing additional fixed-arity versions of the variadic functions you provide so that your consumers don’t need to use the apply method.</p> <h3 id="item-23-never-modify-the-arguments-object">Item 23: Never Modify the arguments Object</h3> <p>✦ Never modify the arguments object.</p> <p>✦ Copy the arguments object to a real array using [].slice.call(arguments) before modifying it.</p> <h3 id="item-24-use-a-variable-to-save-a-reference-to-arguments">Item 24: Use a Variable to Save a Reference to arguments</h3> <p>✦ Be aware of the function nesting level when referring to arguments.</p> <p>✦ Bind an explicitly scoped reference to arguments in order to refer to it from nested functions.</p> <h3 id="item-25-use-bind-to-extract-methods-with-a-fixed-receiver">Item 25: Use bind to Extract Methods with a Fixed Receiver</h3> <p>✦ Beware that extracting a method does not bind the method’s receiver to its object.</p> <p>✦ When passing an object’s method to a higher-order function, use an anonymous function to call the method on the appropriate receiver.</p> <p>✦ Use bind as a shorthand for creating a function bound to the appropriate receiver.</p> <h3 id="item-26-use-bind-to-curry-functions">Item 26: Use bind to Curry Functions</h3> <p>✦ Use bind to curry a function, that is, to create a delegating function with a fixed subset of the required arguments.</p> <p>✦ Pass null or undefined as the receiver argument to curry a function that ignores its receiver.</p> <h3 id="item-27-prefer-closures-to-strings-for-encapsulating-code">Item 27: Prefer Closures to Strings for Encapsulating Code</h3> <p>✦ Never include local references in strings when sending them to APIs that execute them with eval.</p> <p>✦ Prefer APIs that accept functions to call rather than strings to eval.</p> <h3 id="item-28-avoid-relying-on-the-tostring-method-of-functions">Item 28: Avoid Relying on the toString Method of Functions</h3> <p>✦ JavaScript engines are not required to produce accurate reflections of function source code via toString.</p> <p>✦ Never rely on precise details of function source, since different engines may produce different results from toString.</p> <p>✦ The results of toString do not expose the values of local variables stored in a closure.</p> <p>✦ In general, avoid using toString on functions.</p> <h3 id="item-29-avoid-nonstandard-stack-inspection-properties">Item 29: Avoid Nonstandard Stack Inspection Properties</h3> <p>✦ Avoid the nonstandard arguments.caller and arguments.callee, because they are not reliably portable.</p> <p>✦ Avoid the nonstandard caller property of functions, because it does not reliably contain complete information about the stack.</p> <h2 id="4---objects-and-prototypes">4 - Objects and Prototypes</h2> <h3 id="item-30-understand-the-difference-between-prototype-getprototypeof-and__proto__">Item 30: Understand the Difference between prototype, getPrototypeOf, and__proto__</h3> <p>✦ C.prototype determines the prototype of objects created by new C().</p> <p>✦ Object.getPrototypeOf(obj) is the standard ES5 function for retrieving the prototype of an object.</p> <p>✦ obj.<strong>proto</strong> is a nonstandard mechanism for retrieving the proto- type of an object.</p> <p>✦ A class is a design pattern consisting of a constructor function and an associated prototype.</p> <h3 id="item-31-prefer-objectgetprototypeof-to-proto">Item 31: Prefer Object.getPrototypeOf to <strong>proto</strong></h3> <p>✦ Prefer the standards-compliant Object.getPrototypeOf to the non- standard <strong>proto</strong> property.</p> <p>✦ Implement Object.getPrototypeOf in non-ES5 environments that support <strong>proto</strong>.</p> <h3 id="item-32-never-modify-proto">Item 32: Never Modify <strong>proto</strong></h3> <p>✦ Never modify an object’s <strong>proto</strong> property.</p> <p>✦ Use Object.create to provide a custom prototype for new objects.</p> <h3 id="item-33-make-your-constructors-new-agnostic">Item 33: Make Your Constructors new-Agnostic</h3> <p>✦ Make a constructor agnostic to its caller’s syntax by reinvoking itself with new or with Object.create.</p> <p>✦ Document clearly when a function expects to be called with new.</p> <h3 id="item-34-store-methods-on-prototypes">Item 34: Store Methods on Prototypes</h3> <p>✦ Storing methods on instance objects creates multiple copies of the functions, one per instance object.</p> <p>✦ Prefer storing methods on prototypes over storing them on instance objects.</p> <h3 id="item-35-use-closures-to-store-private-data">Item 35: Use Closures to Store Private Data</h3> <p>✦ Closure variables are private, accessible only to local references.</p> <p>✦ Use local variables as private data to enforce information hiding within methods.</p> <h3 id="item-36-store-instance-state-only-on-instance-objects">Item 36: Store Instance State Only on Instance Objects</h3> <p>✦ Mutable data can be problematic when shared, and prototypes are shared between all their instances.</p> <p>✦ Store mutable per-instance state on instance objects.</p> <h3 id="item-37-recognize-the-implicit-binding-of-this">Item 37: Recognize the Implicit Binding of this</h3> <p>✦ The scope of this is always determined by its nearest enclosing function.</p> <p>✦ Use a local variable, usually called self, me, or that, to make a this-binding available to inner functions.</p> <h3 id="item-38-call-superclass-constructors-from-subclass-constructors">Item 38: Call Superclass Constructors from Subclass Constructors</h3> <p>✦ Call the superclass constructor explicitly from subclass construc- tors, passing this as the explicit receiver.</p> <p>✦ Use Object.create to construct the subclass prototype object to avoid calling the superclass constructor.</p> <h3 id="item-39-never-reuse-superclass-property-names">Item 39: Never Reuse Superclass Property Names</h3> <p>✦ Be aware of all property names used by your superclasses.</p> <p>✦ Never reuse a superclass property name in a subclass.</p> <h3 id="item-40-avoid-inheriting-from-standard-classes">Item 40: Avoid Inheriting from Standard Classes</h3> <p>✦ Inheriting from standard classes tends to break due to special internal properties such as [[Class]].</p> <p>✦ Prefer delegating to properties instead of inheriting from standard classes.</p> <h3 id="item-41-treat-prototypes-as-an-implementation-detail">Item 41: Treat Prototypes As an Implementation Detail</h3> <p>✦ Objects are interfaces; prototypes are implementations.</p> <p>✦ Avoid inspecting the prototype structure of objects you don’t control.</p> <p>✦ Avoid inspecting properties that implement the internals of objects you don’t control.</p> <h3 id="item-42-avoid-reckless-monkey-patching">Item 42: Avoid Reckless Monkey-Patching</h3> <p>✦ Avoid reckless monkey-patching.</p> <p>✦ Document any monkey-patching performed by a library.</p> <p>✦ Consider making monkey-patching optional by performing the mod- ifications in an exported function.</p> <p>✦ Use monkey-patching to provide polyfills for missing standard APIs.</p> <h2 id="5---arrays-and-dictionaries">5 - Arrays and Dictionaries</h2> <h3 id="item-43-build-lightweight-dictionaries-from-direct-instances-of-object">Item 43: Build Lightweight Dictionaries from Direct Instances of Object</h3> <p>✦ Use object literals to construct lightweight dictionaries.</p> <p>✦ Lightweight dictionaries should be direct descendants of Object.prototype to protect against prototype pollution in for…in loops.</p> <h3 id="item-44-use-null-prototypes-to-prevent-prototype-pollution">Item 44: Use null Prototypes to Prevent Prototype Pollution</h3> <p>✦ In ES5, use Object.create(null) to create prototype-free empty objects that are less susceptible to pollution.</p> <p>✦ In older environments, consider using { <strong>proto</strong>: null }.</p> <p>✦ But beware that <strong>proto</strong> is neither standard nor entirely portable and may be removed in future JavaScript environments.</p> <p>✦ Never use the name “<strong>proto</strong>” as a dictionary key since some environments treat this property specially.</p> <h3 id="item-45-use-hasownproperty-to-protect-against-prototype-pollution">Item 45: Use hasOwnProperty to Protect Against Prototype Pollution</h3> <p>✦ Use hasOwnProperty to protect against prototype pollution.</p> <p>✦ Use lexical scope and call to protect against overriding of the hasOwnProperty method.</p> <p>✦ Consider implementing dictionary operations in a class that encapsulates the boilerplate hasOwnProperty tests.</p> <p>✦ Use a dictionary class to protect against the use of “<strong>proto</strong>” as a key.</p> <h3 id="item-46-prefer-arrays-to-dictionaries-for-ordered-collections">Item 46: Prefer Arrays to Dictionaries for Ordered Collections</h3> <p>✦ Avoid relying on the order in which for…in loops enumerate object properties.</p> <p>✦ If you aggregate data in a dictionary, make sure the aggregate oper- ations are order-insensitive.</p> <p>✦ Use arrays instead of dictionary objects for ordered collections.</p> <h3 id="item-47-never-add-enumerable-properties-to-objectprototype">Item 47: Never Add Enumerable Properties to Object.prototype</h3> <p>✦ Avoid adding properties to Object.prototype.</p> <p>✦ Consider writing a function instead of an Object.prototype method.</p> <p>✦ If you do add properties to Object.prototype, use ES5’s Object.defineProperty to define them as nonenumerable properties.</p> <h3 id="item-48-avoid-modifying-an-object-during-enumeration">Item 48: Avoid Modifying an Object during Enumeration</h3> <p>✦ Make sure not to modify an object while enumerating its properties with a for…in loop.</p> <p>✦ Use a while loop or classic for loop instead of a for…in loop when iterating over an object whose contents might change during the loop.</p> <p>✦ For predictable enumeration over a changing data structure, con- sider using a sequential data structure such as an array instead of a dictionary object.</p> <h3 id="item-49-prefer-for-loops-to-forin-loops-for-array-iteration">Item 49: Prefer for Loops to for…in Loops for Array Iteration</h3> <p>■ Always use a for loop rather than a for…in loop for iterating over the indexed properties of an array.</p> <p>■ Consider storing the length property of an array in a local vari- able before a loop to avoid recomputing the property lookup.</p> <h3 id="item-50-prefer-iteration-methods-to-loops">Item 50: Prefer Iteration Methods to Loops</h3> <p>✦ Use iteration methods such as Array.prototype.map in place of for loops to make code more read- able and avoid duplicating loop control logic.</p> <p>✦ Use custom iteration functions to abstract common loop patterns that are not provided by the standard library.</p> <p>✦ Traditional loops can still be appropriate in cases where early exit is necessary; alternatively, the some and every methods can be used for early exit.</p> <h3 id="item-51-reuse-generic-array-methods-on-array-like-objects">Item 51: Reuse Generic Array Methods on Array-Like Objects</h3> <p>✦ Reuse generic Array methods on array-like objects by extracting method objects and using their call method.</p> <p>✦ Any object can be used with generic Array methods if it has indexed properties and an appropriate length property.</p> <h3 id="item-52-prefer-array-literals-to-the-array-constructor">Item 52: Prefer Array Literals to the Array Constructor</h3> <p>✦ The Array constructor behaves differently if its first argument is a number.</p> <p>✦ Use array literals instead of the Array constructor.</p> <h2 id="6---library-and-api-design">6 - Library and API Design</h2> <h3 id="item-53-maintain-consistent-conventions">Item 53: Maintain Consistent Conventions</h3> <p>✦ Use consistent conventions for variable names and function signatures.</p> <p>✦ Don’t deviate from conventions your users are likely to encounter in other parts of their development platform.</p> <h3 id="item-54-treat-undefined-as-no-value">Item 54: Treat undefined As “No Value”</h3> <p>✦ Avoid using undefined to represent anything other than the absence of a specific value.</p> <p>✦ Use descriptive string values or objects with named boolean proper- ties, rather than undefined or null, to represent application-specific flags.</p> <p>✦ Test for undefined instead of checking arguments.length to provide parameter default values.</p> <p>✦ Never use truthiness tests for parameter default values that should allow 0, NaN, or the empty string as valid arguments.</p> <h3 id="item-55-accept-options-objects-for-keyword-arguments">Item 55: Accept Options Objects for Keyword Arguments</h3> <p>✦ Use options objects to make APIs more readable and memorable.</p> <p>✦ The arguments provided by an options object should all be treated as optional.</p> <p>✦ Use an extend utility function to abstract out the logic of extracting values from options objects.</p> <h3 id="item-56-avoid-unnecessary-state">Item 56: Avoid Unnecessary State</h3> <p>✦ Prefer stateless APIs where possible.</p> <p>✦ When providing stateful APIs, document the relevant state that each operation depends on.</p> <h3 id="item-57-use-structural-typing-for-flexible-interfaces">Item 57: Use Structural Typing for Flexible Interfaces</h3> <p>✦ Use structural typing (also known as duck typing) for flexible object interfaces.</p> <p>✦ Avoid inheritance when structural interfaces are more flexible and lightweight.</p> <p>✦ Use mock objects, that is, alternative implementations of interfaces that provide repeatable behavior, for unit testing.</p> <h3 id="item-58-distinguish-between-array-and-array-like">Item 58: Distinguish between Array and Array-Like</h3> <p>✦ Never overload structural types with other overlapping types.</p> <p>✦ When overloading a structural type with other types, test for the other types first.</p> <p>✦ Accept true arrays instead of array-like objects when overloading with other object types.</p> <p>✦ Document whether your API accepts true arrays or array-like values.</p> <p>✦ Use ES5’s Array.isArray to test for true arrays.</p> <h3 id="item-59-avoid-excessive-coercion">Item 59: Avoid Excessive Coercion</h3> <p>✦ Avoid mixing coercions with overloading.</p> <p>✦ Consider defensively guarding against unexpected inputs.</p> <h3 id="item-60-support-method-chaining">Item 60: Support Method Chaining</h3> <p>✦ Use method chaining to combine stateless operations.</p> <p>✦ Support method chaining by designing stateless methods that produce new objects.</p> <p>✦ Support method chaining in stateful methods by returning this.</p> <h2 id="7---concurrency">7 - Concurrency</h2> <h3 id="item-61-dont-block-the-event-queue-on-io">Item 61: Don’t Block the Event Queue on I/O</h3> <p>✦ Asynchronous APIs take callbacks to defer processing of expensive operations and avoid blocking the main application.</p> <p>✦ JavaScript accepts events concurrently but processes event handlers sequentially using an event queue.</p> <p>✦ Never use blocking I/O in an application’s event queue.</p> <h3 id="item-62-use-nested-or-named-callbacks-for-asynchronous-sequencing">Item 62: Use Nested or Named Callbacks for Asynchronous Sequencing</h3> <p>✦ Use nested or named callbacks to perform several asynchronous operations in sequence.</p> <p>✦ Try to strike a balance between excessive nesting of callbacks and awkward naming of non-nested callbacks.</p> <p>✦ Avoid sequencing operations that can be performed concurrently.</p> <h3 id="item-63-be-aware-of-dropped-errors">Item 63: Be Aware of Dropped Errors</h3> <p>✦ Avoid copying and pasting error-handling code by writing shared error-handling functions.</p> <p>✦ Make sure to handle all error conditions explicitly to avoid dropped errors.</p> <h3 id="item-64-use-recursion-for-asynchronous-loops">Item 64: Use Recursion for Asynchronous Loops</h3> <p>✦ Loops cannot be asynchronous.</p> <p>✦ Use recursive functions to perform iterations in separate turns of the event loop.</p> <p>✦ Recursion performed in separate turns of the event loop does not overflow the call stack.</p> <h3 id="item-65-dont-block-the-event-queue-on-computation">Item 65: Don’t Block the Event Queue on Computation</h3> <p>✦ Avoid expensive algorithms in the main event queue.</p> <p>✦ On platforms that support it, the Worker API can be used for running long computations in a separate event queue.</p> <p>✦ When the Worker API is not available or is too costly, consider break- ing up computations across multiple turns of the event loop.</p> <h3 id="item-66-use-a-counter-to-perform-concurrent-operations">Item 66: Use a Counter to Perform Concurrent Operations</h3> <p>✦ Events in a JavaScript application occur nondeterministically, that is, in unpredictable order.</p> <p>✦ Use a counter to avoid data races in concurrent operations.</p> <h3 id="item-67-never-call-asynchronous-callbacks-synchronously">Item 67: Never Call Asynchronous Callbacks Synchronously</h3> <p>✦ Never call an asynchronous callback synchronously, even if the data is immediately available.</p> <p>✦ Calling an asynchronous callback synchronously disrupts the expected sequence of operations and can lead to unexpected inter-leaving of code.</p> <p>✦ Calling an asynchronous callback synchronously can lead to stack overflows or mishandled exceptions.</p> <p>✦ Use an asynchronous API such as setTimeout to schedule an asyn- chronous callback to run in another turn.</p> <h3 id="item-68-use-promises-for-cleaner-asynchronous-logic">Item 68: Use Promises for Cleaner Asynchronous Logic</h3> <p>✦ Promises represent eventual values, that is, concurrent computations that eventually produce a result.</p> <p>✦ Use promises to compose different concurrent operations.</p> <p>✦ Use promise APIs to avoid data races.</p> <p>✦ Use select (also known as choose) for situations where an inten- tional race condition is required.</p> <p>————— 低调的配图分界线 —————</p> <p>✦ Effective JavaScript - Loi Wu -</p> <div class="scale"><img src="img/timg10.jpg" alt="Effective JavaScript" /></div> </div> </div> </div> </div> <div class="card" data-id="/2018/10/05/roundchow"> <div class="card__container card__container--closed"> <svg class="card__image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1200" preserveAspectRatio="xMidYMid slice"> <defs> <clipPath id="/2018/10/05/roundchow-clip-path"> <polygon class="clip" points="0,1200 0,0 1920,0 1920,1200"></polygon> </clipPath> </defs> <image clip-path="url(#/2018/10/05/roundchow-clip-path)" width="1920" height="1200" xlink:href="img/timg06.jpg"></image> </svg> <div class="card__content"> <i class="card__btn-close fa fa-times"></i> <div class="card__caption"> <h2 class="card__title">roundchow</h2> <p class="card__subtitle">Hi，欢迎你来</p> </div> <div class="card__copy"> <div class="meta"> <img class="meta__avatar" src="img/authors/timg06.jpg"/> <span class="meta__author">chow</span> <span class="meta__date">2018-10-05</span> </div> <h3 id="roundchow">roundchow</h3> <p>如果你好奇谁是roundchow，以后你会知道的</p> </div> </div> </div> </div> <!-- /cards --> </div> </div> <!-- /container --> </div> <!-- JS --> <script src="js/vendors/trianglify.min.js"></script> <script src="js/vendors/TweenMax.min.js"></script> <script src="js/vendors/ScrollToPlugin.min.js"></script> <script src="js/vendors/cash.min.js"></script> <script src="js/card-modern-blog.js"></script> <script src="js/modern-blog.js"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?9488f1d668fffaacb673941bc920f218"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </body> </html>
