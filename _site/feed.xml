<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>圆周博客</title>
        <description>圆周是和谐的闭环</description>
        <link>http://localhost:4000//</link>
        <atom:link href="http://localhost:4000//feed.xml" rel="self"
        type="application/rss+xml"/>
        <pubDate>Wed, 14 Nov 2018 00:20:26 +0800</pubDate>
        <lastBuildDate>Wed, 14 Nov 2018 00:20:26 +0800</lastBuildDate>
        <generator>Jekyll v3.7.3</generator>
        
        <item>
            <title>若不是我，那该是谁；若非现在，更待何时</title>
            <description>&lt;p&gt;Emma Watson2016联合国女权主义演讲稿&lt;/p&gt;

&lt;p&gt;Today we are launching a campaign called “HeForShe.”&lt;/p&gt;

&lt;p&gt;I am reaching out to you because I need your help. We want to end gender inequality—and to do that we need everyone to be involved.&lt;/p&gt;

&lt;p&gt;This is the first campaign of its kind at the UN: we want to try and galvanize as many men and boys as possible to be advocates for gender equality. And we don’t jus twant to talk about it, but make sure it is tangible.&lt;/p&gt;

&lt;p&gt;I was appointed six months ago and the more I have spoken about feminism the more I haverealized that fighting for women’s rights has too often become synonymous with man-hating. If there is one thing I know for certain, it is that this has tostop.&lt;/p&gt;

&lt;p&gt;For the record, feminism by definition is: “The belief that men and women should have equal rights and opportunities. It is the theory of the political, economic and social equality of the sexes.”&lt;/p&gt;

&lt;p&gt;I started questioning gender-based assumptions when at eight I was confused at being called “bossy,” because I wanted to direct the plays we would put on for our parents—but the boys were not.&lt;/p&gt;

&lt;p&gt;When at 14 I started being sexualized by certain elements of the press.&lt;/p&gt;

&lt;p&gt;When at 15 my girlfriends started dropping out of their sports teams because they didn’t want to appear “muscly.”&lt;/p&gt;

&lt;p&gt;When at 18 my male friends were unable to express their feelings.&lt;/p&gt;

&lt;p&gt;I decided I was a feminist and this seemed uncomplicated to me. But my recent research has shown me that feminism has become an unpopular word.&lt;/p&gt;

&lt;p&gt;Apparently I am among the ranks of women whose expressions are seen as too strong, too aggressive, isolating, anti-men and, unattractive.&lt;/p&gt;

&lt;p&gt;Why is the word such an uncomfortable one?&lt;/p&gt;

&lt;p&gt;I am fromBritain and think it is right that as a woman I am paid the same as my male counterparts. I think it is right that I should be able to make decisions about my own body. I think it is right that women be involved on my behalf in the policies and decision-making of my country. I think it is right that socially I am afforded the same respect as men. But sadly I can say that there is no one country in the world where all women can expect to receive these rights.&lt;/p&gt;

&lt;p&gt;No country in the world can yet say they have achieved gender equality.&lt;/p&gt;

&lt;p&gt;These rights I consider to be human rights but I am one of the lucky ones. My life isa sheer privilege because my parents didn’t love me less because I was born a daughter. My school did not limit me because I was a girl. My mentors didn’t assume I would go less far because I might give birth to a child one day. These influencers were the gender equality ambassadors that made who I am today. They may not know it, but they are the inadvertent feminists who are. And we need more of those. And if you still hate the word—it is not the word that is important but the idea and the ambition behind it. Because not all women have been afforded the same rights that I have. In fact, statistically, very few have been.&lt;/p&gt;

&lt;p&gt;In 1997 ,Hilary Clinton made a famous speech in Beijing about women’s rights. Sadly many of the things she wanted to change are still a reality today.&lt;/p&gt;

&lt;p&gt;But what stood out for me the most was that only 30 per cent of her audience were male.How can we affect change in the world when only half of it is invited or feel welcome to participate in the conversation?&lt;/p&gt;

&lt;p&gt;Men—I would like to take this opportunity to extend your formal invitation. Gender equality is your issue too.&lt;/p&gt;

&lt;p&gt;Because to date, I’ve seen my father’s role as a parent being valued less by society despite my needing his presence as a child as much as my mother’s.&lt;/p&gt;

&lt;p&gt;I’ve seen young men suffering from mental illness unable to ask for help for fear it would make them look less “macho”—in fact in the UK suicide is the biggestkiller of men between 20-49; eclipsing road accidents, cancer and coronary heart disease. I’ve seen men made fragile and insecure by a distorted sense of what constitutes male success. Men don’t have the benefits of equality either.&lt;/p&gt;

&lt;p&gt;We don’t often talk about men being imprisoned by gender stereotypes but I can see that that they are and that when they are free, things will change for women as anatural consequence.&lt;/p&gt;

&lt;p&gt;If men don’t have to be aggressive in order to be accepted women won’t feel compelled to be submissive. If men don’t have to control, women won’t have to be controlled.&lt;/p&gt;

&lt;p&gt;Both men and women should feel free to be sensitive. Both men and women should feel free to be strong… It is time that we all perceive gender on a spectrum not as two opposing sets of ideals.&lt;/p&gt;

&lt;p&gt;If we stop defining each other by what we are not and start defining ourselves by what we are—we can all be freer and this is what HeForShe is about. It’s about freedom.&lt;/p&gt;

&lt;p&gt;I want men to take up this mantle. So their daughters, sisters and mothers can be free from prejudice but also so that their sons have permission to be vulnerable an dhuman too—reclaim those parts of themselves they abandoned and in doing so be a more true and complete version of themselves.&lt;/p&gt;

&lt;p&gt;You migh tbe thinking who is this Harry Potter girl? And what is she doing up on stage at the UN. It’s a good question and trust me I have been asking myself the same thing. I don’t know if I am qualified to be here. All I know is that I care about this problem. And I want to make it better.&lt;/p&gt;

&lt;p&gt;And having seen what I’ve seen—and given the chance—I feel it is my duty to say something. English statesman Edmund Burke said: “All that is needed for the forces of evil to triumph is for enough good men and women to do nothing.”&lt;/p&gt;

&lt;p&gt;In my nervousness for this speech and in my moments of doubt I’ve told myself firmly—if not me, who, if not now, when. If you have similar doubts when opportunities are presented to you I hope those words might be helpful.&lt;/p&gt;

&lt;p&gt;Because the reality is that if we do nothing it will take 75 years, or for me to be nearly a hundred before women can expect to be paid the same as men for the same work. 15.5 million girls will be married in the next 16 years as children.And at current rates it won’t be until 2086 before all rural African girls willbe able to receive a secondary education.&lt;/p&gt;

&lt;p&gt;If you believe in equality, you might be one of those inadvertent feminists I spoke of earlier.&lt;/p&gt;

&lt;p&gt;And for this I applaud you.&lt;/p&gt;

&lt;p&gt;We are struggling for a uniting world but the good news is we have a uniting movement. It is called HeForShe. I am inviting you to step forward, to be seen to speak up, To be the he for she.&lt;/p&gt;

&lt;p&gt;And to ask yourself if not me, who, if not now when.&lt;/p&gt;

&lt;p&gt;Thank you.&lt;/p&gt;

&lt;p&gt;· It’s about freedom - Loi Wu -&lt;/p&gt;

&lt;div class=&quot;scale&quot;&gt;&lt;img src=&quot;img/hugkiss.jpg&quot; alt=&quot;λanguage&quot; /&gt;&lt;/div&gt;
</description>
            <pubDate>Tue, 13 Nov 2018 11:00:00 +0800</pubDate>
            <link>http://localhost:4000/#/2018/11/13/freedom.html</link>
            <guid isPermaLink="true">http://localhost:4000/#/2018/11/13/freedom.html</guid>
            
            
        </item>
        
        <item>
            <title>深入理解站点优化</title>
            <description>&lt;p&gt;优化 Optimization&lt;/p&gt;

&lt;h2 id=&quot;key-points&quot;&gt;Key Points&lt;/h2&gt;

&lt;pre&gt;

· Part 1 - 相关背景知识

1）差异：登陆页面优化、转化率优化、网站测试、网站优化
2）比较：网站优化和SEO

· Part 2 - 分析和测试工具

1）分析工具
2）设置目标：网站转化率、成功衡量指标、基准
3）测试工具

· Part 3 - 为成功打基础

1）关键的优化基础知识

（1）确定当前情况
 
逐项检查：优化检查列表
逐项检查：优化成熟度生命周期

（2）倡导和创建分析及优化文化

定期报告关键成功指标和目标
进行定期培训
定期在全公司范围演讲
举行测试竞赛
寻找公司影响力人物
根据转化率的提高激励团队

（3）准备更好的初始优化策略

（4）创建详细的测试计划

（5）考虑测试外包 - 时机和原因
 
2）理解和创建优化组织

（1）为优化工作找一位执行发起人

（2）获得关键利益相关方的支持

（3）组件专门的优化团队

（4）将测试和优化过程整合到公司中

（5）沟通、审核、迭代

3）测试的最佳实践

（1）试用富有洞察力、假说驱动和迭代式的测试方法

（2）学习创建有效测试的策略

（3）学习定位和个性化对于改进转化的作用

（4）在创建和运行测试时避免常见的错误

（5）学习如何分析结果和确定测试优胜者

· Part 4 - 优化的关键：理解访问者和他们的需求

1）为主要访问者需求建立角色和用例

（1）站在访问者的角度上，创建角色persona和用例case

（2）为访问者创建一些简单的角色

（3）为网站创建用例

（4）在网站上重现用例并评定完成难度级别

（5）学习如何从用例中得到更大的价值

2）创建独特的价值主张并明确的推广
3）直观的分析访问者，理解访问者的意图
4）从访问者满意度和反馈工具中的到深刻见解

· Part 5 - 更高的转化率

1）理解和改进网站布局
2）提高页面加载速度
3）优化导航菜单和链接
4）优化内部网站搜索并从中学习

· Part 6 - 学习对访问者和转化的影响力及说服力

1）影响访问者：优化行动号召、标题、文本
2）提高影响力：优化图片、宣传、视频、富媒体、广告
3）利用社交证据、互惠和稀缺性的力量
4）帮助访问者建立安全感和信任，提高影响力

· Part 7 - 不同页面类型和流程的优化最佳实践及测试思路

1）关注和优化首页
2）优化产品、服务、客户挖掘、其他关键页面
3）优化购物车和结账流程
4）确定其他需要优化的关键页面和流程
5）优化网站的移动体验

· Part 8 - 召回：为重复访问进行优化

1）关注和产生更多的重复访问
2）优化注册或登记页面，获得更多的重复访问
3）优化电子邮件营销活动，获得更多的重复访问

· Part 9 - 回顾结果并从中学习，继续测试和优化

1）复盘：从目前的优化工作中研究和学习
2）持续优化和测试：距离完美还早得很！

&lt;/pre&gt;

&lt;p&gt;· Optimization - Loi Wu -&lt;/p&gt;

&lt;div class=&quot;scale&quot;&gt;&lt;img src=&quot;img/hugkiss.jpg&quot; alt=&quot;λanguage&quot; /&gt;&lt;/div&gt;
</description>
            <pubDate>Sat, 10 Nov 2018 11:00:00 +0800</pubDate>
            <link>http://localhost:4000/#/2018/11/10/optimization.html</link>
            <guid isPermaLink="true">http://localhost:4000/#/2018/11/10/optimization.html</guid>
            
            
        </item>
        
        <item>
            <title>JavaScript快速全栈开发</title>
            <description>&lt;p&gt;JavaScript快速全栈开发&lt;/p&gt;

&lt;h2 id=&quot;knowledge-framework&quot;&gt;Knowledge Framework&lt;/h2&gt;

&lt;pre&gt;

· Part 1 - 知识储备

1）基础知识
（1）定义前端
（2）敏捷开发
（3）定义后端

2）设置环境
（1）搭建本地环境
（2）搭建云端环境

· Part 2 - 前端原型构建

JSON
AJAX
跨域调用
jQuery
Twitter Bootstrap
LESS
Heroku
Backbone.js

· Part 3 - 后端原型构建

Node.js
NPM
MongoDB
BSON

· Part 4 - 整合前后端

不同域部署
JSONP
部署
同域部署

· Part 5 - 干货福利

Node里的异步
Monk
Mocha和TDD
Wintersmith和静态网站生成器
Express.js
Derby

&lt;/pre&gt;

&lt;h2 id=&quot;key-points&quot;&gt;Key Points&lt;/h2&gt;

&lt;p&gt;· &lt;a href=&quot;https://www.json.org/&quot;&gt;JSON&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

JSON (JavaScript Object Notation) is a lightweight data-interchange format.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;http://www.adaptivepath.org/ideas/ajax-new-approach-web-applications/&quot;&gt;Ajax&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

Ajax (Asynchronous JavaScript And XML) is a set of Web development techniques using many Web technologies on the client side to create asychronous Web applications.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;CORS&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

Cross-origin resource sharing (CORS) is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served.[1] A web page may freely embed cross-origin images, stylesheets, scripts, iframes, and videos.[2] Certain &quot;cross-domain&quot; requests, notably Ajax requests, are forbidden by default by the same-origin security policy.

CORS defines a way in which a browser and server can interact to determine whether or not it is safe to allow the cross-origin request.[3] It allows for more freedom and functionality than purely same-origin requests, but is more secure than simply allowing all cross-origin requests. The specification for CORS was originally published as a W3C Recommendation[4] but that document is obsolete.[5] The current actively-maintained specification that defines CORS is WHATWG's Fetch Living Standard.[6] 

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

jQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document traversal and manipulation, event handling, animation, and Ajax much simpler with an easy-to-use API that works across a multitude of browsers. With a combination of versatility and extensibility, jQuery has changed the way that millions of people write JavaScript.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://getbootstrap.com/&quot;&gt;Bootstrap&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

Build responsive, mobile-first projects on the web with the world's most popular front-end component library (Bootstrap自己说的).

Bootstrap is an open source toolkit for developing with HTML, CSS and JS. Quickly prototype the ideas or build the entire app with the Sass variables and mixins, responsive grid system, extensive prebuilt components, and powerful plugins built on jQuery.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;http://lesscss.org/&quot;&gt;LESS&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

Less (which stands for Leaner Style Sheets) is a backwards-compatible language extension for CSS. This is the official documentation for Less, the language and Less.js, the JavaScript tool that converts your Less styles to CSS styles.

Because Less looks just like CSS, learning it is a breeze. Less only makes a few convenient additions to the CSS language, which is one of the reasons it can be learned so quickly.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

Heroku is a cloud platform based on a managed container system, with integrated data services and powerful ecosystem, for deploying and runnding modern apps.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;http://backbonejs.org/&quot;&gt;Backbone.js&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

 Backbone.js gives structure to web applications by providing models with key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing API over a RESTful JSON interface.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

npm is the package manager for JavaScript and the world’s largest software registry. Discover packages of reusable code — and assemble them in powerful new ways.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://www.mongodb.com/what-is-mongodb&quot;&gt;MongoDB&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

MongoDB is a document database with the scalability and flexibility that you want with the querying and indexing that you need.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;http://bsonspec.org/&quot;&gt;BSON&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

BSON [bee · sahn], short for Bin­ary JSON, is a bin­ary-en­coded seri­al­iz­a­tion of JSON-like doc­u­ments. Like JSON, BSON sup­ports the em­bed­ding of doc­u­ments and ar­rays with­in oth­er doc­u­ments and ar­rays. BSON also con­tains ex­ten­sions that al­low rep­res­ent­a­tion of data types that are not part of the JSON spec. For ex­ample, BSON has a Date type and a BinData type.

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_deployment&quot;&gt;软件部署&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

Software deployment is all of the activities that make a software system available for use.

The general deployment process consists of several interrelated activities with possible transitions between them. These activities can occur at the producer side or at the consumer side or both. Because every software system is unique, the precise processes or procedures within each activity can hardly be defined. Therefore, &quot;deployment&quot; should be interpreted as a general process that has to be customized according to specific requirements or characteristics. 

&lt;/pre&gt;

&lt;p&gt;· &lt;a href=&quot;https://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;

JSONP (JSON with Padding or JSON-P) is a JavaScript pattern to request data by loading a script tag. JSONP enables sharing of data bypassing same-origin policy.

&lt;/pre&gt;

&lt;p&gt;Rapid Prototyping with JS: Agile JavaScript Development - Loi Wu -&lt;/p&gt;

&lt;div class=&quot;scale&quot;&gt;&lt;img src=&quot;img/hugkiss.jpg&quot; alt=&quot;λanguage&quot; /&gt;&lt;/div&gt;

</description>
            <pubDate>Fri, 09 Nov 2018 11:00:00 +0800</pubDate>
            <link>http://localhost:4000/#/2018/11/09/agile-javascript-development.html</link>
            <guid isPermaLink="true">http://localhost:4000/#/2018/11/09/agile-javascript-development.html</guid>
            
            
        </item>
        
        <item>
            <title>λanguage - 如何实现一门编程语言</title>
            <description>&lt;p&gt;How to implement a programming language in JavaScript&lt;/p&gt;

&lt;p&gt;如何用JavaScript实现一门编程语言&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;· Write a parser 编写词法分析器&lt;/p&gt;

&lt;p&gt;· Write an interpreter 编写解释器&lt;/p&gt;

&lt;p&gt;· &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation&quot;&gt;Continuations 延续&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;· Write a compiler 编写编译器&lt;/p&gt;

&lt;p&gt;· Transform code to continuation-passing style 将代码转换成“连续传递的风格”&lt;/p&gt;

&lt;p&gt;· Optimization techniques 优化技术&lt;/p&gt;

&lt;p&gt;· Examples of what λanguage brings new over plain JavaScript 
λanguage基于JavaScript之上的新特性示例&lt;/p&gt;

&lt;h2 id=&quot;λanguage-description&quot;&gt;λanguage description&lt;/h2&gt;

&lt;p&gt;Before anything, we should have a clear picture about what we’re trying to achieve. 开工之前，我们先要对即将实现的目标有一个清晰的认识。It’s a good idea to put together a rigorous description of the grammar. 接下来，我们把语法严格的描述出来，举个例子：&lt;/p&gt;

&lt;pre&gt;
# this is a comment
println(&quot;Hello λanguage!&quot;);
println(2 + 3 * 4);
# functions are introduced with `lambda` or `λ`
fib = lambda (n) if n &amp;lt; 2 then n else fib(n - 1) + fib(n - 2);
println(fib(15));
print-range = λ(a, b)             # `λ` is synonym to `lambda`
                if a &amp;lt;= b then {  # `then` here is optional as you can see below
                  print(a);
                  if a + 1 &amp;lt;= b {
                    print(&quot;, &quot;);
                    print-range(a + 1, b);
                  } else println(&quot;&quot;);        # newline
                };
print-range(1, 5);
&lt;/pre&gt;

&lt;p&gt;The output is 输出:&lt;/p&gt;

&lt;pre&gt;
Hello World!
14
610
1, 2, 3, 4, 5
&lt;/pre&gt;

&lt;p&gt;evaluates an expression 计算表达式:&lt;/p&gt;

&lt;pre&gt;
a = {
  fib(10);  # has no side-effects, but it's computed anyway
  fib(15)   # the last semicolon can be missing
};
print(a); # prints 610
&lt;/pre&gt;

&lt;p&gt;ternary operator 三目运算符:&lt;/p&gt;

&lt;pre&gt;
a = foo() ? bar() : baz();           // JavaScript
a = if foo() then bar() else baz();  # λanguage
&lt;/pre&gt;

&lt;p&gt;if expression if表达式:&lt;/p&gt;

&lt;pre&gt;
if foo() then print(&quot;It will print &quot;OK&quot; if and only if the result of foo() is NOT false.&quot;);
&lt;/pre&gt;

&lt;h2 id=&quot;writing-a-parser&quot;&gt;Writing a parser&lt;/h2&gt;

&lt;p&gt;In essence, a parser must transform a piece of code (which we inspect by looking at the characters) into an “abstract syntax tree” (AST). The AST is a structured in-memory representation of the program, and it’s “abstract” in the sense that it does not care exactly what characters is the source code made of, but it faithfully represents the semantics of it. 词法分析器，通过检查每一个字符，解决将代码转换成AST抽象语法树的任务。之所以称之为“抽象”，是因为AST并不关心源代码是由什么字符所组成的，它只是严格的呈现源代码的语义。&lt;/p&gt;

&lt;p&gt;For example, for the following program text 举个例子，对于以下的程序文本:&lt;/p&gt;

&lt;pre&gt;
sum = lambda(a, b) {
  a + b;
};
print(sum(1, 2));
&lt;/pre&gt;

&lt;p&gt;The parser will generate the following AST, as a JavaScript object: 词法分析器会产生如下的抽象语法树，形如一个JavaScript对象：&lt;/p&gt;

&lt;pre&gt;
{
  type: &quot;prog&quot;,
  prog: [
    // first line:
    {
      type: &quot;assign&quot;,
      operator: &quot;=&quot;,
      left: { type: &quot;var&quot;, value: &quot;sum&quot; },
      right: {
        type: &quot;lambda&quot;,
        vars: [ &quot;a&quot;, &quot;b&quot; ],
        body: {
          // the body should be a &quot;prog&quot;, but because
          // it contains a single expression, our parser
          // reduces it to the expression itself.
          type: &quot;binary&quot;,
          operator: &quot;+&quot;,
          left: { type: &quot;var&quot;, value: &quot;a&quot; },
          right: { type: &quot;var&quot;, value: &quot;b&quot; }
        }
      }
    },
    // second line:
    {
      type: &quot;call&quot;,
      func: { type: &quot;var&quot;, value: &quot;print&quot; },
      args: [{
        type: &quot;call&quot;,
        func: { type: &quot;var&quot;, value: &quot;sum&quot; },
        args: [ { type: &quot;num&quot;, value: 1 },
                { type: &quot;num&quot;, value: 2 } ]
      }]
    }
  ]
}
&lt;/pre&gt;

&lt;p&gt;The main difficulty in writing a parser consists in a failure to properly organize the code. The parser should operate at a higher level than reading characters from a string. A few advices on how to keep complexity manageable: 编写一个词法解析器解析器的主要困难在于未能恰当地组织代码。词法解析器的运作，应该高于从字符串中读取字符的层面。针对控制词法解析器编写的复杂度程度，以下给出三个建议：&lt;/p&gt;

&lt;p&gt;· Write many functions and keep them small. In every function, do one thing and do it well. 多写函数并尽量保持单个函数的精简，在每个函数中，一次做好一件事。&lt;/p&gt;

&lt;p&gt;· Do not try to use regexps for parsing. They don’t work. Regexps can be helpful in the lexer though, but I suggest to limit them to very simple things. 不要在词法分析时使用正则表达式，此时正则不管用。虽然正则有助于词法的分析，但建议在处理简单的事情时，克制对正则的使用。&lt;/p&gt;

&lt;p&gt;· Don’t attempt to guess. When unsure how to parse something, throw an error and make sure the message contains the error location (line/column). 绝对不要胡乱瞎猜。如果词法分析时遇到了不确定的情况，可以抛出异常，并确保错误信息里包含了异常发生的代码行/列。&lt;/p&gt;

&lt;h3 id=&quot;input-stream---the-character-input-stream-字符输入流&quot;&gt;Input stream - The character input stream 字符输入流&lt;/h3&gt;

&lt;p&gt;This is the smallest part. We’re going to create a “stream object” which provides operations to read characters from a string. 首先编写“流对象”，提供一组操作，从字符串里读取字符。&lt;/p&gt;

&lt;p&gt;A stream object has 4 methods 流对象包含4种方法:&lt;/p&gt;

&lt;p&gt;· peek() — returns the next value but without removing it from the stream. 
返回下一个值。但不在流中将其去除。&lt;/p&gt;

&lt;p&gt;· next() — returns the next value and also discards it from the stream.
返回下一个值。同时在流中将其去除。&lt;/p&gt;

&lt;p&gt;· eof() — returns true if and only if there are no more values in the stream.
返回真，当且仅当流中没有更多值。&lt;/p&gt;

&lt;p&gt;· croak(msg) — does throw new Error(msg). 
抛出异常new Error(msg)，便于追踪和定位发生异常的代码片段。&lt;/p&gt;

&lt;p&gt;The full code of “InputStream” object: 以下是实现“输入流”对象的完整代码：&lt;/p&gt;

&lt;pre&gt;
function InputStream(input) {
    var pos = 0, line = 1, col = 0;
    return {
        next  : next,
        peek  : peek,
        eof   : eof,
        croak : croak,
    };
    function next() {
        var ch = input.charAt(pos++);
        if (ch == &quot;\n&quot;) line++, col = 0; else col++;
        return ch;
    }
    function peek() {
        return input.charAt(pos);
    }
    function eof() {
        return peek() == &quot;&quot;;
    }
    function croak(msg) {
        throw new Error(msg + &quot; (&quot; + line + &quot;:&quot; + col + &quot;)&quot;);
    }
}
&lt;/pre&gt;

&lt;h3 id=&quot;token-stream---the-token-input-stream-分词输入流&quot;&gt;Token stream - The token input stream 分词输入流&lt;/h3&gt;

&lt;p&gt;The tokenizer (also called “lexer”) operates on a character input stream and returns a stream object with the same interface, but the values returned by peek() / next() will be tokens. A token is an object with two properties: type and value. 分词器（或称“词法分析器”）对字符输入流进行操作，并通过相同接口返回对象流。不过对于peek() / next()的处理，仍然返回分词。分词是一种具有type和value两个属性的对象。&lt;/p&gt;

&lt;p&gt;Here are some examples with supported tokens: 以下示例给出一些支持的分词形式：&lt;/p&gt;

&lt;pre&gt;
{ type: &quot;punc&quot;, value: &quot;(&quot; }           // punctuation: parens, comma, semicolon etc.
{ type: &quot;num&quot;, value: 5 }              // numbers
{ type: &quot;str&quot;, value: &quot;Hello World!&quot; } // strings
{ type: &quot;kw&quot;, value: &quot;lambda&quot; }        // keywords
{ type: &quot;var&quot;, value: &quot;a&quot; }            // identifiers
{ type: &quot;op&quot;, value: &quot;!=&quot; }            // operators
&lt;/pre&gt;

&lt;p&gt;Whitespace and comments are skipped over, no tokens are returned. 空格和注释会被跳过，不返回分词。&lt;/p&gt;

&lt;p&gt;In order to write the tokenizer we need to look more closely into the syntax of our language. The idea is to notice that depending on the current character (as returned by input.peek()) we can decide what kind of token to read: 为了编写分词器，先对将要实现的编程语言的语法进行仔细的确认。通过input.peek()返回的当前字符，可以确定正在读取什么样的分词：&lt;/p&gt;

&lt;p&gt;· First off, skip over whitespace. 首先，略去空格。&lt;/p&gt;

&lt;p&gt;· If input.eof() then return null. 如果遇到input.eof()，则返回null（空）。&lt;/p&gt;

&lt;p&gt;· If it’s a sharp sign (#), skip comment (retry after the end of line). 如果遇到#，略去注释。在最后一行之后进行重试。&lt;/p&gt;

&lt;p&gt;· If it’s a quote then read a string. 如果遇到引号quote，就紧接着读取字符串string。&lt;/p&gt;

&lt;p&gt;· If it’s a digit, then we proceed to read a number. 如果遇到数位digit，就进行数字的读取。&lt;/p&gt;

&lt;p&gt;· If it’s a “letter”, then read an identifier or a keyword token. 如果遇到字母“letter”，就读取一个标识符或一个关键词分词。&lt;/p&gt;

&lt;p&gt;· If it’s one of the punctuation characters, return a punctuation token. 如果遇到标点字符，就返回对应的标点分词。&lt;/p&gt;

&lt;p&gt;· If it’s one of the operator characters, return an operator token. 如果遇到一个运算符字符，就返回对应的运算符分词。&lt;/p&gt;

&lt;p&gt;· If none of the above, error out with input.croak(). 如果遇到的是非上述的内容，就通过input.croak()抛出异常信息。&lt;/p&gt;

&lt;p&gt;So here’s the “read_next” function — the “core” of the tokenizer — which implements the above: 以下是函数“read_next”，它是分词器的核心部分，是对上述规则的具体实现：&lt;/p&gt;

&lt;pre&gt;
function read_next() {
    read_while(is_whitespace);
    if (input.eof()) return null;
    var ch = input.peek();
    if (ch == &quot;#&quot;) {
        skip_comment();
        return read_next();
    }
    if (ch == '&quot;') return read_string();
    if (is_digit(ch)) return read_number();
    if (is_id_start(ch)) return read_ident();
    if (is_punc(ch)) return {
        type  : &quot;punc&quot;,
        value : input.next()
    };
    if (is_op_char(ch)) return {
        type  : &quot;op&quot;,
        value : read_while(is_op_char)
    };
    input.croak(&quot;Can't handle character: &quot; + ch);
}
&lt;/pre&gt;

&lt;p&gt;This is a “dispatcher” function and it’s what next() will call in order to fetch the next token. Note it uses many utilities that are focused on particular token types, like read_string(), read_number() etc. There’s no point to complicate the dispatcher with code from those functions, even if we never call them elsewhere. 这是一个“调度器（dispatcher）”函数，当next()被调用时触发，以获取下一个分词。注意到它使用了不少工具方法来判断特定的分词类型，比如read_string(), read_number()等。没必要在调度器dispatcher函数里实现这些方法，从而增加代码的复杂度。&lt;/p&gt;

&lt;p&gt;The code pretty much speaks for itself now, so here is the complete tokenizer for our language. 代码自己会说话，以下是这个新的编程语言完整的分词器的实现：&lt;/p&gt;

&lt;pre&gt;
function TokenStream(input) {
    var current = null;
    var keywords = &quot; if then else lambda λ true false &quot;;
    return {
        next  : next,
        peek  : peek,
        eof   : eof,
        croak : input.croak
    };
    function is_keyword(x) {
        return keywords.indexOf(&quot; &quot; + x + &quot; &quot;) &amp;gt;= 0;
    }
    function is_digit(ch) {
        return /[0-9]/i.test(ch);
    }
    function is_id_start(ch) {
        return /[a-zλ_]/i.test(ch);
    }
    function is_id(ch) {
        return is_id_start(ch) || &quot;?!-&amp;lt;&amp;gt;=0123456789&quot;.indexOf(ch) &amp;gt;= 0;
    }
    function is_op_char(ch) {
        return &quot;+-*/%=&amp;amp;|&amp;lt;&amp;gt;!&quot;.indexOf(ch) &amp;gt;= 0;
    }
    function is_punc(ch) {
        return &quot;,;(){}[]&quot;.indexOf(ch) &amp;gt;= 0;
    }
    function is_whitespace(ch) {
        return &quot; \t\n&quot;.indexOf(ch) &amp;gt;= 0;
    }
    function read_while(predicate) {
        var str = &quot;&quot;;
        while (!input.eof() &amp;amp;&amp;amp; predicate(input.peek()))
            str += input.next();
        return str;
    }
    function read_number() {
        var has_dot = false;
        var number = read_while(function(ch){
            if (ch == &quot;.&quot;) {
                if (has_dot) return false;
                has_dot = true;
                return true;
            }
            return is_digit(ch);
        });
        return { type: &quot;num&quot;, value: parseFloat(number) };
    }
    function read_ident() {
        var id = read_while(is_id);
        return {
            type  : is_keyword(id) ? &quot;kw&quot; : &quot;var&quot;,
            value : id
        };
    }
    function read_escaped(end) {
        var escaped = false, str = &quot;&quot;;
        input.next();
        while (!input.eof()) {
            var ch = input.next();
            if (escaped) {
                str += ch;
                escaped = false;
            } else if (ch == &quot;\\&quot;) {
                escaped = true;
            } else if (ch == end) {
                break;
            } else {
                str += ch;
            }
        }
        return str;
    }
    function read_string() {
        return { type: &quot;str&quot;, value: read_escaped('&quot;') };
    }
    function skip_comment() {
        read_while(function(ch){ return ch != &quot;\n&quot; });
        input.next();
    }
    function read_next() {
        read_while(is_whitespace);
        if (input.eof()) return null;
        var ch = input.peek();
        if (ch == &quot;#&quot;) {
            skip_comment();
            return read_next();
        }
        if (ch == '&quot;') return read_string();
        if (is_digit(ch)) return read_number();
        if (is_id_start(ch)) return read_ident();
        if (is_punc(ch)) return {
            type  : &quot;punc&quot;,
            value : input.next()
        };
        if (is_op_char(ch)) return {
            type  : &quot;op&quot;,
            value : read_while(is_op_char)
        };
        input.croak(&quot;Can't handle character: &quot; + ch);
    }
    function peek() {
        return current || (current = read_next());
    }
    function next() {
        var tok = current;
        current = null;
        return tok || read_next();
    }
    function eof() {
        return peek() == null;
    }
}
&lt;/pre&gt;

&lt;p&gt;· The next() function doesn’t always call read_next(), because it might have been peeked before (in which case read_next() was already called and the stream advanced). Therefore we need a current variable which keeps track of the current token. 函数next()不会每次都调用到read_next()。通过专门的current变量来追踪当前处理的分词。&lt;/p&gt;

&lt;p&gt;· We only support decimal numbers with the usual notation (no 1E5 stuff, no hex, no octal). But if we ever need more, the changes go only in read_number() and are pretty easy to do. 该编程语言只支持常见十进制数，如果需要支持更多的符号，可以通过完善函数read_number()来实现。&lt;/p&gt;

&lt;p&gt;· Unlike JavaScript, the only characters that cannot appear unquoted in a string are the quote character itself and the backslash. You need to backslash them. Otherwise strings can contain hard newlines, tabs, and whatnot. We don’t interpret the usual escapes like \n, \t etc. though again, the changes would be pretty trivial (in “read_string”).&lt;/p&gt;

&lt;h3 id=&quot;the-ast&quot;&gt;The AST&lt;/h3&gt;

&lt;p&gt;As mentioned, the parser will build a structure which faithfully represents the semantics of the program. An AST node is a plain JavaScript object that has a type property specifying what kind of node it is, and additional information, depending on the particular type. 词法分析器parser，可以为程序创建一种严格表达语义的结构。一个AST抽象语法树节点是纯JavaScript对象，它拥有一个类型属性以表明节点的类型，并根据不同的节点类型，附加更多的信息。&lt;/p&gt;

&lt;pre&gt;
In short:

    · num { type: &quot;num&quot;, value: NUMBER }
    · str { type: &quot;str&quot;, value: STRING }
    · bool { type: &quot;bool&quot;, value: true or false }
    · var { type: &quot;var&quot;, value: NAME }
    · lambda { type: &quot;lambda&quot;, vars: [ NAME... ], body: AST }
    · call { type: &quot;call&quot;, func: AST, args: [ AST... ] }
    · if { type: &quot;if&quot;, cond: AST, then: AST, else: AST }
    · assign { type: &quot;assign&quot;, operator: &quot;=&quot;, left: AST, right: AST }
    · binary { type: &quot;binary&quot;, operator: OPERATOR, left: AST, right: AST }
    · prog { type: &quot;prog&quot;, prog: [ AST... ] }
    · let { type: &quot;let&quot;, vars: [ VARS... ], body: AST }

&lt;/pre&gt;

&lt;pre&gt;
Examples:

Numbers (&quot;num&quot;)
123.5 
-&amp;gt;
{ type: &quot;num&quot;, value: 123.5 }

Strings (&quot;str&quot;)
&quot;Hello World!&quot;
-&amp;gt;
{ type: &quot;str&quot;, value: &quot;Hello World!&quot; }

Booleans (&quot;bool&quot;)
true
-&amp;gt;
{ type: &quot;bool&quot;, value: true }
false
-&amp;gt;
{ type: &quot;bool&quot;, value: false }

Identifiers (&quot;var&quot;)
foo
-&amp;gt;
{ type: &quot;var&quot;, value: &quot;foo&quot; }

Functions (&quot;lambda&quot;)
lambda (x) 10   
# or 
λ (x) 10 
-&amp;gt; 
{
  type: &quot;lambda&quot;,
  vars: [ &quot;x&quot; ],
  body: { type: &quot;num&quot;, value: 10 }
}

Function calls (&quot;call&quot;)
foo(a, 1) 
-&amp;gt;
{
  &quot;type&quot;: &quot;call&quot;,
  &quot;func&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;foo&quot; },
  &quot;args&quot;: [
    { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;a&quot; },
    { &quot;type&quot;: &quot;num&quot;, &quot;value&quot;: 1 }
  ]
}

Conditionals (&quot;if&quot;) 
if foo then bar else baz 
-&amp;gt;
{
  &quot;type&quot;: &quot;if&quot;,
  &quot;cond&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;foo&quot; },
  &quot;then&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;bar&quot; },
  &quot;else&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;baz&quot; }
}

The else branch is optional:
if foo then bar 
-&amp;gt;
{
  &quot;type&quot;: &quot;if&quot;,
  &quot;cond&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;foo&quot; },
  &quot;then&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;bar&quot; }
}

Assignment (&quot;assign&quot;)
a = 10 
-&amp;gt;
{
  &quot;type&quot;: &quot;assign&quot;,
  &quot;operator&quot;: &quot;=&quot;,
  &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;a&quot; },
  &quot;right&quot;: { &quot;type&quot;: &quot;num&quot;, &quot;value&quot;: 10 }
}

Binary expressions (&quot;binary&quot;)
x + y * z 
-&amp;gt;
{
  &quot;type&quot;: &quot;binary&quot;,
  &quot;operator&quot;: &quot;+&quot;,
  &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;x&quot; },
  &quot;right&quot;: {
    &quot;type&quot;: &quot;binary&quot;,
    &quot;operator&quot;: &quot;*&quot;,
    &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;y&quot; },
    &quot;right&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;z&quot; }
  }
}

Sequences (&quot;prog&quot;)
{
  a = 5;
  b = a * 2;
  a + b;
}
-&amp;gt;
{
  &quot;type&quot;: &quot;prog&quot;,
  &quot;prog&quot;: [
    {
      &quot;type&quot;: &quot;assign&quot;,
      &quot;operator&quot;: &quot;=&quot;,
      &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;a&quot; },
      &quot;right&quot;: { &quot;type&quot;: &quot;num&quot;, &quot;value&quot;: 5 }
    },
    {
      &quot;type&quot;: &quot;assign&quot;,
      &quot;operator&quot;: &quot;=&quot;,
      &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;b&quot; },
      &quot;right&quot;: {
        &quot;type&quot;: &quot;binary&quot;,
        &quot;operator&quot;: &quot;*&quot;,
        &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;a&quot; },
        &quot;right&quot;: { &quot;type&quot;: &quot;num&quot;, &quot;value&quot;: 2 }
      }
    },
    {
      &quot;type&quot;: &quot;binary&quot;,
      &quot;operator&quot;: &quot;+&quot;,
      &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;a&quot; },
      &quot;right&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;b&quot; }
    }
  ]
}

Block scoped variables (&quot;let&quot;)
let (a = 10, b = a * 10) {
  a + b;
}
-&amp;gt;
{
  &quot;type&quot;: &quot;let&quot;,
  &quot;vars&quot;: [
    {
      &quot;name&quot;: &quot;a&quot;,
      &quot;def&quot;: { &quot;type&quot;: &quot;num&quot;, &quot;value&quot;: 10 }
    },
    {
      &quot;name&quot;: &quot;b&quot;,
      &quot;def&quot;: {
        &quot;type&quot;: &quot;binary&quot;,
        &quot;operator&quot;: &quot;*&quot;,
        &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;a&quot; },
        &quot;right&quot;: { &quot;type&quot;: &quot;num&quot;, &quot;value&quot;: 10 }
      }
    }
  ],
  &quot;body&quot;: {
    &quot;type&quot;: &quot;binary&quot;,
    &quot;operator&quot;: &quot;+&quot;,
    &quot;left&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;a&quot; },
    &quot;right&quot;: { &quot;type&quot;: &quot;var&quot;, &quot;value&quot;: &quot;b&quot; }
  }
}

&lt;/pre&gt;

&lt;h3 id=&quot;the-parser&quot;&gt;The parser&lt;/h3&gt;

&lt;p&gt;The parser creates AST nodes that are described in the AST section. 词法分析器生成AST抽象语法树描述中对应的AST节点。&lt;/p&gt;

&lt;p&gt;Thanks to the work we did in the tokenizer, the parser operates on a stream of tokens instead of dealing with individual characters. It still defines many helpers to keep complexity down. I’ll discuss here the main functions that comprise the parser. Let’s start with a high level one, the lambda parser: 在分词器运作的基础上，词法分析器并不是处理独立的字符，而是处理分词流。通过定义丰富的工具方法，可以降低代码的复杂程度。首先，从构成词法分析器的主函数开始进行讨论，以下是lambda分析器：&lt;/p&gt;

&lt;pre&gt;
function parse_lambda() {
    return {
        type: &quot;lambda&quot;,
        vars: delimited(&quot;(&quot;, &quot;)&quot;, &quot;,&quot;, parse_varname),
        body: parse_expression()
    };
}
&lt;/pre&gt;

&lt;p&gt;This function will be invoked when the lambda keyword has already been seen and “eaten” from the input, so all it cares for is to parse the argument names; but they’re in parentheses and delimited by commas. Rather than placing that code in parse_lambda, I preferred to write a delimited function that takes these arguments: the start token, the end token, the separator, and a function which parses whatever must be between those start/end tokens. In this case, it’s parse_varname, which takes care to throw an error if it encounters anything which doesn’t look like a variable. The body of the function is an expression, so we get it with parse_expression. 当关键词lambda出现并进入输入流时，函数parse_lambda将被调用，所以此时只关心参数名称的解析。这些参数被圆括号括起，并用逗号隔开。&lt;/p&gt;

&lt;p&gt;delimited is a bit lower-level:&lt;/p&gt;

&lt;pre&gt;
function delimited(start, stop, separator, parser) {
    var a = [], first = true;
    skip_punc(start);
    while (!input.eof()) {
        if (is_punc(stop)) break;
        if (first) first = false; else skip_punc(separator);
        if (is_punc(stop)) break; // the last separator can be missing
        a.push(parser());
    }
    skip_punc(stop);
    return a;
}
&lt;/pre&gt;

&lt;p&gt;The function that parses the whole program is probably the simplest:&lt;/p&gt;

&lt;pre&gt;
function parse_toplevel() {
    var prog = [];
    while (!input.eof()) {
        prog.push(parse_expression());
        if (!input.eof()) skip_punc(&quot;;&quot;);
    }
    return { type: &quot;prog&quot;, prog: prog };
}
&lt;/pre&gt;

&lt;p&gt;Another simple example: parse_if():&lt;/p&gt;

&lt;pre&gt;
function parse_if() {
    skip_kw(&quot;if&quot;);
    var cond = parse_expression();
    if (!is_punc(&quot;{&quot;)) skip_kw(&quot;then&quot;);
    var then = parse_expression();
    var ret = { type: &quot;if&quot;, cond: cond, then: then };
    if (is_kw(&quot;else&quot;)) {
        input.next();
        ret.else = parse_expression();
    }
    return ret;
}
&lt;/pre&gt;

&lt;p&gt;parse_atom() does the main dispatching job, depending on the current token:&lt;/p&gt;

&lt;pre&gt;
function parse_atom() {
    return maybe_call(function(){
        if (is_punc(&quot;(&quot;)) {
            input.next();
            var exp = parse_expression();
            skip_punc(&quot;)&quot;);
            return exp;
        }
        if (is_punc(&quot;{&quot;)) return parse_prog();
        if (is_kw(&quot;if&quot;)) return parse_if();
        if (is_kw(&quot;true&quot;) || is_kw(&quot;false&quot;)) return parse_bool();
        if (is_kw(&quot;lambda&quot;) || is_kw(&quot;λ&quot;)) {
            input.next();
            return parse_lambda();
        }
        var tok = input.next();
        if (tok.type == &quot;var&quot; || tok.type == &quot;num&quot; || tok.type == &quot;str&quot;)
            return tok;
        unexpected();
    });
}
&lt;/pre&gt;

&lt;pre&gt;
// we're going to use the FALSE node in various places,
// so I'm making it a global.
var FALSE = { type: &quot;bool&quot;, value: false };

function parse_prog() {
    var prog = delimited(&quot;{&quot;, &quot;}&quot;, &quot;;&quot;, parse_expression);
    if (prog.length == 0) return FALSE;
    if (prog.length == 1) return prog[0];
    return { type: &quot;prog&quot;, prog: prog };
}
&lt;/pre&gt;

&lt;p&gt;Here’s the parse_expression() function. Contrary to parse_atom(), this one will extend an expression as much as possible to the right using maybe_binary(), which is explained below:&lt;/p&gt;

&lt;pre&gt;
function parse_expression() {
    return maybe_call(function(){
        return maybe_binary(parse_atom(), 0);
    });
}
&lt;/pre&gt;

&lt;h4 id=&quot;the-maybe_-functions&quot;&gt;The maybe_* functions&lt;/h4&gt;

&lt;p&gt;These functions check what follows after an expression in order to decide whether to wrap that expression in another node, or just return it as is.&lt;/p&gt;

&lt;p&gt;maybe_call() is very simple. It receives a function that is expected to parse the current expression. If after that expression it sees a ( punctuation token, then it must be a “call” node, which is what parse_call() makes (included below). Notice again how delimited() comes in handy for reading the argument list.&lt;/p&gt;

&lt;pre&gt;
function maybe_call(expr) {
    expr = expr();
    return is_punc(&quot;(&quot;) ? parse_call(expr) : expr;
}

function parse_call(func) {
    return {
        type: &quot;call&quot;,
        func: func,
        args: delimited(&quot;(&quot;, &quot;)&quot;, &quot;,&quot;, parse_expression)
    };
}
&lt;/pre&gt;

&lt;p&gt;Operator precedence&lt;/p&gt;

&lt;p&gt;maybe_binary(left, my_prec) is used to compose binary expressions like 1 + 2 * 3. The trick to parse them properly is to correctly define the operator precedence, so we’ll start with that:&lt;/p&gt;

&lt;pre&gt;
var PRECEDENCE = {
    &quot;=&quot;: 1,
    &quot;||&quot;: 2,
    &quot;&amp;amp;&amp;amp;&quot;: 3,
    &quot;&amp;lt;&quot;: 7, &quot;&amp;gt;&quot;: 7, &quot;&amp;lt;=&quot;: 7, &quot;&amp;gt;=&quot;: 7, &quot;==&quot;: 7, &quot;!=&quot;: 7,
    &quot;+&quot;: 10, &quot;-&quot;: 10,
    &quot;*&quot;: 20, &quot;/&quot;: 20, &quot;%&quot;: 20,
};
&lt;/pre&gt;

&lt;p&gt;If it’s an operator that has a higher precedence than ours, then it wraps left in a new “binary” node, and for the right side it repeats the trick at the new precedence level (*):&lt;/p&gt;

&lt;pre&gt;
function maybe_binary(left, my_prec) {
    var tok = is_op();
    if (tok) {
        var his_prec = PRECEDENCE[tok.value];
        if (his_prec &amp;gt; my_prec) {
            input.next();
            var right = maybe_binary(parse_atom(), his_prec) // (*);
            var binary = {
                type     : tok.value == &quot;=&quot; ? &quot;assign&quot; : &quot;binary&quot;,
                operator : tok.value,
                left     : left,
                right    : right
            };
            return maybe_binary(binary, my_prec);
        }
    }
    return left;
}
&lt;/pre&gt;

&lt;p&gt;the whole parse function:&lt;/p&gt;

&lt;pre&gt;
var FALSE = { type: &quot;bool&quot;, value: false };
function parse(input) {
    var PRECEDENCE = {
        &quot;=&quot;: 1,
        &quot;||&quot;: 2,
        &quot;&amp;amp;&amp;amp;&quot;: 3,
        &quot;&amp;lt;&quot;: 7, &quot;&amp;gt;&quot;: 7, &quot;&amp;lt;=&quot;: 7, &quot;&amp;gt;=&quot;: 7, &quot;==&quot;: 7, &quot;!=&quot;: 7,
        &quot;+&quot;: 10, &quot;-&quot;: 10,
        &quot;*&quot;: 20, &quot;/&quot;: 20, &quot;%&quot;: 20,
    };
    return parse_toplevel();
    function is_punc(ch) {
        var tok = input.peek();
        return tok &amp;amp;&amp;amp; tok.type == &quot;punc&quot; &amp;amp;&amp;amp; (!ch || tok.value == ch) &amp;amp;&amp;amp; tok;
    }
    function is_kw(kw) {
        var tok = input.peek();
        return tok &amp;amp;&amp;amp; tok.type == &quot;kw&quot; &amp;amp;&amp;amp; (!kw || tok.value == kw) &amp;amp;&amp;amp; tok;
    }
    function is_op(op) {
        var tok = input.peek();
        return tok &amp;amp;&amp;amp; tok.type == &quot;op&quot; &amp;amp;&amp;amp; (!op || tok.value == op) &amp;amp;&amp;amp; tok;
    }
    function skip_punc(ch) {
        if (is_punc(ch)) input.next();
        else input.croak(&quot;Expecting punctuation: \&quot;&quot; + ch + &quot;\&quot;&quot;);
    }
    function skip_kw(kw) {
        if (is_kw(kw)) input.next();
        else input.croak(&quot;Expecting keyword: \&quot;&quot; + kw + &quot;\&quot;&quot;);
    }
    function skip_op(op) {
        if (is_op(op)) input.next();
        else input.croak(&quot;Expecting operator: \&quot;&quot; + op + &quot;\&quot;&quot;);
    }
    function unexpected() {
        input.croak(&quot;Unexpected token: &quot; + JSON.stringify(input.peek()));
    }
    function maybe_binary(left, my_prec) {
        var tok = is_op();
        if (tok) {
            var his_prec = PRECEDENCE[tok.value];
            if (his_prec &amp;gt; my_prec) {
                input.next();
                return maybe_binary({
                    type     : tok.value == &quot;=&quot; ? &quot;assign&quot; : &quot;binary&quot;,
                    operator : tok.value,
                    left     : left,
                    right    : maybe_binary(parse_atom(), his_prec)
                }, my_prec);
            }
        }
        return left;
    }
    function delimited(start, stop, separator, parser) {
        var a = [], first = true;
        skip_punc(start);
        while (!input.eof()) {
            if (is_punc(stop)) break;
            if (first) first = false; else skip_punc(separator);
            if (is_punc(stop)) break;
            a.push(parser());
        }
        skip_punc(stop);
        return a;
    }
    function parse_call(func) {
        return {
            type: &quot;call&quot;,
            func: func,
            args: delimited(&quot;(&quot;, &quot;)&quot;, &quot;,&quot;, parse_expression),
        };
    }
    function parse_varname() {
        var name = input.next();
        if (name.type != &quot;var&quot;) input.croak(&quot;Expecting variable name&quot;);
        return name.value;
    }
    function parse_if() {
        skip_kw(&quot;if&quot;);
        var cond = parse_expression();
        if (!is_punc(&quot;{&quot;)) skip_kw(&quot;then&quot;);
        var then = parse_expression();
        var ret = {
            type: &quot;if&quot;,
            cond: cond,
            then: then,
        };
        if (is_kw(&quot;else&quot;)) {
            input.next();
            ret.else = parse_expression();
        }
        return ret;
    }
    function parse_lambda() {
        return {
            type: &quot;lambda&quot;,
            vars: delimited(&quot;(&quot;, &quot;)&quot;, &quot;,&quot;, parse_varname),
            body: parse_expression()
        };
    }
    function parse_bool() {
        return {
            type  : &quot;bool&quot;,
            value : input.next().value == &quot;true&quot;
        };
    }
    function maybe_call(expr) {
        expr = expr();
        return is_punc(&quot;(&quot;) ? parse_call(expr) : expr;
    }
    function parse_atom() {
        return maybe_call(function(){
            if (is_punc(&quot;(&quot;)) {
                input.next();
                var exp = parse_expression();
                skip_punc(&quot;)&quot;);
                return exp;
            }
            if (is_punc(&quot;{&quot;)) return parse_prog();
            if (is_kw(&quot;if&quot;)) return parse_if();
            if (is_kw(&quot;true&quot;) || is_kw(&quot;false&quot;)) return parse_bool();
            if (is_kw(&quot;lambda&quot;) || is_kw(&quot;λ&quot;)) {
                input.next();
                return parse_lambda();
            }
            var tok = input.next();
            if (tok.type == &quot;var&quot; || tok.type == &quot;num&quot; || tok.type == &quot;str&quot;)
                return tok;
            unexpected();
        });
    }
    function parse_toplevel() {
        var prog = [];
        while (!input.eof()) {
            prog.push(parse_expression());
            if (!input.eof()) skip_punc(&quot;;&quot;);
        }
        return { type: &quot;prog&quot;, prog: prog };
    }
    function parse_prog() {
        var prog = delimited(&quot;{&quot;, &quot;}&quot;, &quot;;&quot;, parse_expression);
        if (prog.length == 0) return FALSE;
        if (prog.length == 1) return prog[0];
        return { type: &quot;prog&quot;, prog: prog };
    }
    function parse_expression() {
        return maybe_call(function(){
            return maybe_binary(parse_atom(), 0);
        });
    }
}
&lt;/pre&gt;

&lt;h2 id=&quot;simple-interpreter&quot;&gt;Simple interpreter&lt;/h2&gt;

&lt;p&gt;We wrote 3 functions: InputStream, TokenStream and parse. To get an AST from a piece of code now we can do the following: 我们已经实现3个功能InputStream，TokenStream和parse。为了从代码块中解析出AST抽象语法树，可以进行如下的代码操作：&lt;/p&gt;

&lt;pre&gt;
var ast = parse(TokenStream(InputStream(code)));
&lt;/pre&gt;

&lt;p&gt;· 以下未完待续&lt;/p&gt;

&lt;pre&gt;

### Test what we have

### Adding new constructs

### How fast are we?

## CPS Evaluator

### Guarding the stack

### Continuations

#### Yield (advanced)

## Compiling to JS

### JS code generator

### CPS transformer

#### Samples

#### Improvements

### Optimizer

## Wrapping up

## Real samples

### Primitives

### catDir

### copyTree sequential

### copyTree parallel

### In fairness to Node

### Error handling

&lt;/pre&gt;

&lt;p&gt;· How to implement a programming language in JavaScript - Loi Wu -&lt;/p&gt;

&lt;div class=&quot;scale&quot;&gt;&lt;img src=&quot;img/hugkiss.jpg&quot; alt=&quot;λanguage&quot; /&gt;&lt;/div&gt;

</description>
            <pubDate>Fri, 26 Oct 2018 11:00:00 +0800</pubDate>
            <link>http://localhost:4000/#/2018/10/26/Language.html</link>
            <guid isPermaLink="true">http://localhost:4000/#/2018/10/26/Language.html</guid>
            
            
        </item>
        
        <item>
            <title>Effective JavaScript</title>
            <description>&lt;p&gt;Effective JavaScript&lt;/p&gt;

&lt;h2 id=&quot;1---accustoming-yourself-to-javascript&quot;&gt;1 - Accustoming Yourself to JavaScript&lt;/h2&gt;

&lt;h3 id=&quot;item-1-know-which-javascript-you-are-using&quot;&gt;Item 1: Know Which JavaScript You Are Using&lt;/h3&gt;

&lt;p&gt;✦ Decide which versions of JavaScript your application supports.&lt;/p&gt;

&lt;p&gt;✦ Be sure that any JavaScript features you use are supported by all environments where your application runs.&lt;/p&gt;

&lt;p&gt;✦ Always test strict code in environments that perform the strict-mode checks.&lt;/p&gt;

&lt;p&gt;✦ Beware of concatenating scripts that differ in their expectations about strict mode.&lt;/p&gt;

&lt;h3 id=&quot;item-2-understand-javascripts-floating-point-numbers&quot;&gt;Item 2: Understand JavaScript’s Floating-Point Numbers&lt;/h3&gt;

&lt;p&gt;✦ JavaScript numbers are double-precision floating-point numbers.&lt;/p&gt;

&lt;p&gt;✦ Integers in JavaScript are just a subset of doubles rather than a separate datatype.&lt;/p&gt;

&lt;p&gt;✦ Bitwise operators treat numbers as if they were 32-bit signed integers.&lt;/p&gt;

&lt;p&gt;✦ Be aware of limitations of precisions in flaoting-point arithmetic.&lt;/p&gt;

&lt;h3 id=&quot;item-3-beware-of-implicit-coercions&quot;&gt;Item 3: Beware of Implicit Coercions&lt;/h3&gt;

&lt;p&gt;✦ Type errors can be silently hidden by implicit coercions.&lt;/p&gt;

&lt;p&gt;✦ The + operator is overloaded to do addition or string concatenation depending on its argument types.&lt;/p&gt;

&lt;p&gt;✦ Objects are coerced to numbers via valueOf and to strings via toString.&lt;/p&gt;

&lt;p&gt;✦ Objects with valueOf methods should implement a toString method taht provides a string representation of the number produced by valueOf.&lt;/p&gt;

&lt;p&gt;✦ Use typeof or comparison to undefined rather than truthiness to test for undefined values.&lt;/p&gt;

&lt;h3 id=&quot;item-4-prefer-primitives-to-object-wrappers&quot;&gt;Item 4: Prefer Primitives to Object Wrappers&lt;/h3&gt;

&lt;p&gt;✦ Object wrappers for primitive types do not have the same behavior as their primitive calues when compared for equality.&lt;/p&gt;

&lt;p&gt;✦ Getting and setting properties on primitives implicitly creates object wrappers.&lt;/p&gt;

&lt;h3 id=&quot;item-5-avoid-using--with-mixed-types&quot;&gt;Item 5: Avoid using == with Mixed Types&lt;/h3&gt;

&lt;p&gt;✦ The == operator applies a confusing set of implicit coercoins when its arguments are of different types.&lt;/p&gt;

&lt;p&gt;✦ Use === to make it clear to your readers that your comparison does not involve any implicit coercions.&lt;/p&gt;

&lt;p&gt;✦ Use your own explicit coercions when comparing values of different types to make your program’s behavior clearer.&lt;/p&gt;

&lt;h3 id=&quot;item-6-learn-the-limits-of-semicolon-insertion&quot;&gt;Item 6: Learn the Limits of Semicolon Insertion&lt;/h3&gt;

&lt;p&gt;✦ Semicolons are only ever inferred before a }, at the end of a line, or at the end of a program.&lt;/p&gt;

&lt;p&gt;✦ Semicolons are only ever inffered when the next token cannot be parsed.&lt;/p&gt;

&lt;p&gt;✦ Never omit a semicolon before a statement beginning with (, [, +, -, or /.&lt;/p&gt;

&lt;p&gt;✦ When concatenating scripts, insert semicolons explicitly between scripts.&lt;/p&gt;

&lt;p&gt;✦ Never put a newline before the argument to return, throw, break, continue, ++, or –.&lt;/p&gt;

&lt;p&gt;✦ Semicolons are never inferred as separators in the head of a for loop or as empty statements.&lt;/p&gt;

&lt;h3 id=&quot;item-7-think-of-strings-as-sequences-of-16-bit-code-units&quot;&gt;Item 7: Think of Strings As Sequences of 16-Bit Code Units&lt;/h3&gt;

&lt;p&gt;✦ JavaScript strings consist of 16-bit code units, not Unicode code points.&lt;/p&gt;

&lt;p&gt;✦ Unicode code points 2^16 and above are represented in JavaScript by two code units, known as a surrogate pair.&lt;/p&gt;

&lt;p&gt;✦ Surrogate pairs throw off string element counts, affecting length, charAt, charCodeAt, and regular expression patterns such as “.”.&lt;/p&gt;

&lt;p&gt;✦ Use third-party libraries for writing code point-aware string manipulation.&lt;/p&gt;

&lt;p&gt;✦ Whenever you are using a library that works with strings, consult the documentation to see how it handles the full range of code points.&lt;/p&gt;

&lt;h2 id=&quot;2---variable-scope&quot;&gt;2 - Variable Scope&lt;/h2&gt;

&lt;h3 id=&quot;item-8-minimize-use-of-the-global-object&quot;&gt;Item 8: Minimize Use of the Global Object&lt;/h3&gt;

&lt;p&gt;✦ Avoid declaring global variables.&lt;/p&gt;

&lt;p&gt;✦ Declare variables as locally as possible.&lt;/p&gt;

&lt;p&gt;✦ Avoid adding properties to the global object.&lt;/p&gt;

&lt;p&gt;✦ Use the global object for platform feature detection.&lt;/p&gt;

&lt;h3 id=&quot;item-9-always-declare-local-variables&quot;&gt;Item 9: Always Declare Local Variables&lt;/h3&gt;

&lt;p&gt;✦ Always declare new local variables with var.&lt;/p&gt;

&lt;p&gt;✦ Consider using lint tools to help check for unbound variables.&lt;/p&gt;

&lt;h3 id=&quot;item-10-avoid-with&quot;&gt;Item 10: Avoid with&lt;/h3&gt;

&lt;p&gt;✦ Avoid using with statements.&lt;/p&gt;

&lt;p&gt;✦ Use short variable names for repeated access to an object.&lt;/p&gt;

&lt;p&gt;✦ Explicitly bind local variables to object properties instead of implicitly binding them with a with statement.&lt;/p&gt;

&lt;h3 id=&quot;item-11-get-comfortable-with-closures&quot;&gt;Item 11: Get Comfortable with Closures&lt;/h3&gt;

&lt;p&gt;✦ Functions can refer to variables defined in outer scopes.&lt;/p&gt;

&lt;p&gt;✦ Closures can outlive the function that creates them.&lt;/p&gt;

&lt;p&gt;✦ Closures internally store references to their outer variables, and can both read and update their stored variables.&lt;/p&gt;

&lt;h3 id=&quot;item-12-understand-variable-hoisting&quot;&gt;Item 12: Understand Variable Hoisting&lt;/h3&gt;

&lt;p&gt;✦ Variable declarations within a block are implicitly hoisted to the top of their enclosing function.&lt;/p&gt;

&lt;p&gt;✦ Redeclarations of a variable are treated as a single variable.&lt;/p&gt;

&lt;p&gt;✦ Consider manually hoisting local variable declarations to avoid confusion.&lt;/p&gt;

&lt;h3 id=&quot;item-13-use-immediately-invoked-function-expressions-to-create-local-scopes&quot;&gt;Item 13: Use Immediately Invoked Function Expressions to Create Local Scopes&lt;/h3&gt;

&lt;p&gt;✦ Understand the difference between binding and assignment.&lt;/p&gt;

&lt;p&gt;✦ Closures capture their outer variables by reference, not by value.&lt;/p&gt;

&lt;p&gt;✦ Use immediately invoked function expressions (IIFEs) to create local scopes.&lt;/p&gt;

&lt;p&gt;✦ Be aware of the cases where wrapping a block in an IIFE can change its behavior.&lt;/p&gt;

&lt;h3 id=&quot;item-14-beware-of-unportable-scoping-of-named-function-expressions&quot;&gt;Item 14: Beware of Unportable Scoping of Named Function Expressions&lt;/h3&gt;

&lt;p&gt;✦ Use named function expressions to improve stack traces in Error objects and debuggers.&lt;/p&gt;

&lt;p&gt;✦ Beware of pollution of function expression scope with Object .prototype in ES3 and buggy JavaScript environments.&lt;/p&gt;

&lt;p&gt;✦ Beware of hoisting and duplicate allocation of named function expressions in buggy JavaScript environments.&lt;/p&gt;

&lt;p&gt;✦ Consider avoiding named function expressions or removing them before shipping.&lt;/p&gt;

&lt;p&gt;✦ If you are shipping in properly implemented ES5 environments, you’ve got nothing to worry about.&lt;/p&gt;

&lt;h3 id=&quot;item-15-beware-of-unportable-scoping-of-block-local-function-declarations&quot;&gt;Item 15: Beware of Unportable Scoping of Block-Local Function Declarations&lt;/h3&gt;

&lt;p&gt;✦ Always keep function declarations at the outermost level of a program or a containing function to avoid unportable behavior.&lt;/p&gt;

&lt;p&gt;✦ Use var declarations with conditional assignment instead of conditional function declarations.&lt;/p&gt;

&lt;h3 id=&quot;item-16-avoid-creating-local-variables-with-eval&quot;&gt;Item 16: Avoid Creating Local Variables with eval&lt;/h3&gt;

&lt;p&gt;✦ Avoid creating variables with eval that pollute the caller’s scope.&lt;/p&gt;

&lt;p&gt;✦ If eval code might create global variables, wrap the call in a nested function to prevent scope pollution.&lt;/p&gt;

&lt;h3 id=&quot;item-17-prefer-indirect-eval-to-direct-eval&quot;&gt;Item 17: Prefer Indirect eval to Direct eval&lt;/h3&gt;

&lt;p&gt;✦ Wrap eval in a sequence expression with a useless literal to force the use of indirect eval.&lt;/p&gt;

&lt;p&gt;✦ Prefer indirect eval to direct eval whenever possible.&lt;/p&gt;

&lt;h2 id=&quot;3---working-with-functions&quot;&gt;3 - Working with Functions&lt;/h2&gt;

&lt;h3 id=&quot;item-18-understand-the-difference-between-function-method-and-constructor-calls&quot;&gt;Item 18: Understand the Difference between Function, Method, and Constructor Calls&lt;/h3&gt;

&lt;p&gt;✦ Method calls provide the object in which the method property is looked up as their receiver.&lt;/p&gt;

&lt;p&gt;✦ Function calls provide the global object (or undefined for strict func- tions) as their receiver. Calling methods with function call syntax is rarely useful.&lt;/p&gt;

&lt;p&gt;✦ Constructors are called with new and receive a fresh object as their receiver.&lt;/p&gt;

&lt;h3 id=&quot;item-19-get-comfortable-using-higher-order-functions&quot;&gt;Item 19: Get Comfortable Using Higher-Order Functions&lt;/h3&gt;

&lt;p&gt;✦ Higher-order functions are functions that take other functions as arguments or return functions as their result.&lt;/p&gt;

&lt;p&gt;✦ Familiarize yourself with higher-order functions in existing libraries.&lt;/p&gt;

&lt;p&gt;✦ Learn to detect common coding patterns that can be replaced by higher-order functions.&lt;/p&gt;

&lt;h3 id=&quot;item-20-use-call-to-call-methods-with-a-custom-receiver&quot;&gt;Item 20: Use call to Call Methods with a Custom Receiver&lt;/h3&gt;

&lt;p&gt;✦ Use the call method to call a function with a custom receiver.&lt;/p&gt;

&lt;p&gt;✦ Use the call method for calling methods that may not exist on a given object.&lt;/p&gt;

&lt;p&gt;✦ Use the call method for defining higher-order functions that allow clients to provide a receiver for the callback.&lt;/p&gt;

&lt;h3 id=&quot;item-21-use-apply-to-call-functions-with-different-numbers-of-arguments&quot;&gt;Item 21: Use apply to Call Functions with Different Numbers of Arguments&lt;/h3&gt;

&lt;p&gt;✦ Use the apply method to call variadic functions with a computed array of arguments.&lt;/p&gt;

&lt;p&gt;✦ Use the first argument of apply to provide a receiver for variadic methods.&lt;/p&gt;

&lt;h3 id=&quot;item-22-use-arguments-to-create-variadic-functions&quot;&gt;Item 22: Use arguments to Create Variadic Functions&lt;/h3&gt;

&lt;p&gt;✦ Use the implicit arguments object to implement variable-arity functions.&lt;/p&gt;

&lt;p&gt;✦ Consider providing additional fixed-arity versions of the variadic functions you provide so that your consumers don’t need to use the apply method.&lt;/p&gt;

&lt;h3 id=&quot;item-23-never-modify-the-arguments-object&quot;&gt;Item 23: Never Modify the arguments Object&lt;/h3&gt;

&lt;p&gt;✦ Never modify the arguments object.&lt;/p&gt;

&lt;p&gt;✦ Copy the arguments object to a real array using [].slice.call(arguments) before modifying it.&lt;/p&gt;

&lt;h3 id=&quot;item-24-use-a-variable-to-save-a-reference-to-arguments&quot;&gt;Item 24: Use a Variable to Save a Reference to arguments&lt;/h3&gt;

&lt;p&gt;✦ Be aware of the function nesting level when referring to arguments.&lt;/p&gt;

&lt;p&gt;✦ Bind an explicitly scoped reference to arguments in order to refer to it from nested functions.&lt;/p&gt;

&lt;h3 id=&quot;item-25-use-bind-to-extract-methods-with-a-fixed-receiver&quot;&gt;Item 25: Use bind to Extract Methods with a Fixed Receiver&lt;/h3&gt;

&lt;p&gt;✦ Beware that extracting a method does not bind the method’s receiver to its object.&lt;/p&gt;

&lt;p&gt;✦ When passing an object’s method to a higher-order function, use an anonymous function to call the method on the appropriate receiver.&lt;/p&gt;

&lt;p&gt;✦ Use bind as a shorthand for creating a function bound to the appropriate receiver.&lt;/p&gt;

&lt;h3 id=&quot;item-26-use-bind-to-curry-functions&quot;&gt;Item 26: Use bind to Curry Functions&lt;/h3&gt;

&lt;p&gt;✦ Use bind to curry a function, that is, to create a delegating function with a fixed subset of the required arguments.&lt;/p&gt;

&lt;p&gt;✦ Pass null or undefined as the receiver argument to curry a function that ignores its receiver.&lt;/p&gt;

&lt;h3 id=&quot;item-27-prefer-closures-to-strings-for-encapsulating-code&quot;&gt;Item 27: Prefer Closures to Strings for Encapsulating Code&lt;/h3&gt;

&lt;p&gt;✦ Never include local references in strings when sending them to APIs that execute them with eval.&lt;/p&gt;

&lt;p&gt;✦ Prefer APIs that accept functions to call rather than strings to eval.&lt;/p&gt;

&lt;h3 id=&quot;item-28-avoid-relying-on-the-tostring-method-of-functions&quot;&gt;Item 28: Avoid Relying on the toString Method of Functions&lt;/h3&gt;

&lt;p&gt;✦ JavaScript engines are not required to produce accurate reflections of function source code via toString.&lt;/p&gt;

&lt;p&gt;✦ Never rely on precise details of function source, since different engines may produce different results from toString.&lt;/p&gt;

&lt;p&gt;✦ The results of toString do not expose the values of local variables stored in a closure.&lt;/p&gt;

&lt;p&gt;✦ In general, avoid using toString on functions.&lt;/p&gt;

&lt;h3 id=&quot;item-29-avoid-nonstandard-stack-inspection-properties&quot;&gt;Item 29: Avoid Nonstandard Stack Inspection Properties&lt;/h3&gt;

&lt;p&gt;✦ Avoid the nonstandard arguments.caller and arguments.callee, because they are not reliably portable.&lt;/p&gt;

&lt;p&gt;✦ Avoid the nonstandard caller property of functions, because it does not reliably contain complete information about the stack.&lt;/p&gt;

&lt;h2 id=&quot;4---objects-and-prototypes&quot;&gt;4 - Objects and Prototypes&lt;/h2&gt;

&lt;h3 id=&quot;item-30-understand-the-difference-between-prototype-getprototypeof-and__proto__&quot;&gt;Item 30: Understand the Difference between prototype, getPrototypeOf, and__proto__&lt;/h3&gt;

&lt;p&gt;✦ C.prototype determines the prototype of objects created by new C().&lt;/p&gt;

&lt;p&gt;✦ Object.getPrototypeOf(obj) is the standard ES5 function for retrieving the prototype of an object.&lt;/p&gt;

&lt;p&gt;✦ obj.&lt;strong&gt;proto&lt;/strong&gt; is a nonstandard mechanism for retrieving the proto- type of an object.&lt;/p&gt;

&lt;p&gt;✦ A class is a design pattern consisting of a constructor function and an associated prototype.&lt;/p&gt;

&lt;h3 id=&quot;item-31-prefer-objectgetprototypeof-to-proto&quot;&gt;Item 31: Prefer Object.getPrototypeOf to &lt;strong&gt;proto&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;✦ Prefer the standards-compliant Object.getPrototypeOf to the non- standard &lt;strong&gt;proto&lt;/strong&gt; property.&lt;/p&gt;

&lt;p&gt;✦ Implement Object.getPrototypeOf in non-ES5 environments that support &lt;strong&gt;proto&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;item-32-never-modify-proto&quot;&gt;Item 32: Never Modify &lt;strong&gt;proto&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;✦ Never modify an object’s &lt;strong&gt;proto&lt;/strong&gt; property.&lt;/p&gt;

&lt;p&gt;✦ Use Object.create to provide a custom prototype for new objects.&lt;/p&gt;

&lt;h3 id=&quot;item-33-make-your-constructors-new-agnostic&quot;&gt;Item 33: Make Your Constructors new-Agnostic&lt;/h3&gt;

&lt;p&gt;✦ Make a constructor agnostic to its caller’s syntax by reinvoking itself with new or with Object.create.&lt;/p&gt;

&lt;p&gt;✦ Document clearly when a function expects to be called with new.&lt;/p&gt;

&lt;h3 id=&quot;item-34-store-methods-on-prototypes&quot;&gt;Item 34: Store Methods on Prototypes&lt;/h3&gt;

&lt;p&gt;✦ Storing methods on instance objects creates multiple copies of the functions, one per instance object.&lt;/p&gt;

&lt;p&gt;✦ Prefer storing methods on prototypes over storing them on instance objects.&lt;/p&gt;

&lt;h3 id=&quot;item-35-use-closures-to-store-private-data&quot;&gt;Item 35: Use Closures to Store Private Data&lt;/h3&gt;

&lt;p&gt;✦ Closure variables are private, accessible only to local references.&lt;/p&gt;

&lt;p&gt;✦ Use local variables as private data to enforce information hiding within methods.&lt;/p&gt;

&lt;h3 id=&quot;item-36-store-instance-state-only-on-instance-objects&quot;&gt;Item 36: Store Instance State Only on Instance Objects&lt;/h3&gt;

&lt;p&gt;✦ Mutable data can be problematic when shared, and prototypes are shared between all their instances.&lt;/p&gt;

&lt;p&gt;✦ Store mutable per-instance state on instance objects.&lt;/p&gt;

&lt;h3 id=&quot;item-37-recognize-the-implicit-binding-of-this&quot;&gt;Item 37: Recognize the Implicit Binding of this&lt;/h3&gt;

&lt;p&gt;✦ The scope of this is always determined by its nearest enclosing function.&lt;/p&gt;

&lt;p&gt;✦ Use a local variable, usually called self, me, or that, to make a this-binding available to inner functions.&lt;/p&gt;

&lt;h3 id=&quot;item-38-call-superclass-constructors-from-subclass-constructors&quot;&gt;Item 38: Call Superclass Constructors from Subclass Constructors&lt;/h3&gt;

&lt;p&gt;✦ Call the superclass constructor explicitly from subclass construc- tors, passing this as the explicit receiver.&lt;/p&gt;

&lt;p&gt;✦ Use Object.create to construct the subclass prototype object to avoid calling the superclass constructor.&lt;/p&gt;

&lt;h3 id=&quot;item-39-never-reuse-superclass-property-names&quot;&gt;Item 39: Never Reuse Superclass Property Names&lt;/h3&gt;

&lt;p&gt;✦ Be aware of all property names used by your superclasses.&lt;/p&gt;

&lt;p&gt;✦ Never reuse a superclass property name in a subclass.&lt;/p&gt;

&lt;h3 id=&quot;item-40-avoid-inheriting-from-standard-classes&quot;&gt;Item 40: Avoid Inheriting from Standard Classes&lt;/h3&gt;

&lt;p&gt;✦ Inheriting from standard classes tends to break due to special internal properties such as [[Class]].&lt;/p&gt;

&lt;p&gt;✦ Prefer delegating to properties instead of inheriting from standard classes.&lt;/p&gt;

&lt;h3 id=&quot;item-41-treat-prototypes-as-an-implementation-detail&quot;&gt;Item 41: Treat Prototypes As an Implementation Detail&lt;/h3&gt;

&lt;p&gt;✦ Objects are interfaces; prototypes are implementations.&lt;/p&gt;

&lt;p&gt;✦ Avoid inspecting the prototype structure of objects you don’t control.&lt;/p&gt;

&lt;p&gt;✦ Avoid inspecting properties that implement the internals of objects you don’t control.&lt;/p&gt;

&lt;h3 id=&quot;item-42-avoid-reckless-monkey-patching&quot;&gt;Item 42: Avoid Reckless Monkey-Patching&lt;/h3&gt;

&lt;p&gt;✦ Avoid reckless monkey-patching.&lt;/p&gt;

&lt;p&gt;✦ Document any monkey-patching performed by a library.&lt;/p&gt;

&lt;p&gt;✦ Consider making monkey-patching optional by performing the mod- ifications in an exported function.&lt;/p&gt;

&lt;p&gt;✦ Use monkey-patching to provide polyfills for missing standard APIs.&lt;/p&gt;

&lt;h2 id=&quot;5---arrays-and-dictionaries&quot;&gt;5 - Arrays and Dictionaries&lt;/h2&gt;

&lt;h3 id=&quot;item-43-build-lightweight-dictionaries-from-direct-instances-of-object&quot;&gt;Item 43: Build Lightweight Dictionaries from Direct Instances of Object&lt;/h3&gt;

&lt;p&gt;✦ Use object literals to construct lightweight dictionaries.&lt;/p&gt;

&lt;p&gt;✦ Lightweight dictionaries should be direct descendants of Object.prototype to protect against prototype pollution in for…in loops.&lt;/p&gt;

&lt;h3 id=&quot;item-44-use-null-prototypes-to-prevent-prototype-pollution&quot;&gt;Item 44: Use null Prototypes to Prevent Prototype Pollution&lt;/h3&gt;

&lt;p&gt;✦ In ES5, use Object.create(null) to create prototype-free empty objects that are less susceptible to pollution.&lt;/p&gt;

&lt;p&gt;✦ In older environments, consider using { &lt;strong&gt;proto&lt;/strong&gt;: null }.&lt;/p&gt;

&lt;p&gt;✦ But beware that &lt;strong&gt;proto&lt;/strong&gt; is neither standard nor entirely portable and may be removed in future JavaScript environments.&lt;/p&gt;

&lt;p&gt;✦ Never use the name “&lt;strong&gt;proto&lt;/strong&gt;” as a dictionary key since some environments treat this property specially.&lt;/p&gt;

&lt;h3 id=&quot;item-45-use-hasownproperty-to-protect-against-prototype-pollution&quot;&gt;Item 45: Use hasOwnProperty to Protect Against Prototype Pollution&lt;/h3&gt;

&lt;p&gt;✦ Use hasOwnProperty to protect against prototype pollution.&lt;/p&gt;

&lt;p&gt;✦ Use lexical scope and call to protect against overriding of the hasOwnProperty method.&lt;/p&gt;

&lt;p&gt;✦ Consider implementing dictionary operations in a class that encapsulates the boilerplate hasOwnProperty tests.&lt;/p&gt;

&lt;p&gt;✦ Use a dictionary class to protect against the use of “&lt;strong&gt;proto&lt;/strong&gt;” as a key.&lt;/p&gt;

&lt;h3 id=&quot;item-46-prefer-arrays-to-dictionaries-for-ordered-collections&quot;&gt;Item 46: Prefer Arrays to Dictionaries for Ordered Collections&lt;/h3&gt;

&lt;p&gt;✦ Avoid relying on the order in which for…in loops enumerate object properties.&lt;/p&gt;

&lt;p&gt;✦ If you aggregate data in a dictionary, make sure the aggregate oper- ations are order-insensitive.&lt;/p&gt;

&lt;p&gt;✦ Use arrays instead of dictionary objects for ordered collections.&lt;/p&gt;

&lt;h3 id=&quot;item-47-never-add-enumerable-properties-to-objectprototype&quot;&gt;Item 47: Never Add Enumerable Properties to Object.prototype&lt;/h3&gt;

&lt;p&gt;✦ Avoid adding properties to Object.prototype.&lt;/p&gt;

&lt;p&gt;✦ Consider writing a function instead of an Object.prototype method.&lt;/p&gt;

&lt;p&gt;✦ If you do add properties to Object.prototype, use ES5’s Object.defineProperty to define them as nonenumerable properties.&lt;/p&gt;

&lt;h3 id=&quot;item-48-avoid-modifying-an-object-during-enumeration&quot;&gt;Item 48: Avoid Modifying an Object during Enumeration&lt;/h3&gt;

&lt;p&gt;✦ Make sure not to modify an object while enumerating its properties with a for…in loop.&lt;/p&gt;

&lt;p&gt;✦ Use a while loop or classic for loop instead of a for…in loop when iterating over an object whose contents might change during the loop.&lt;/p&gt;

&lt;p&gt;✦ For predictable enumeration over a changing data structure, con- sider using a sequential data structure such as an array instead of a dictionary object.&lt;/p&gt;

&lt;h3 id=&quot;item-49-prefer-for-loops-to-forin-loops-for-array-iteration&quot;&gt;Item 49: Prefer for Loops to for…in Loops for Array Iteration&lt;/h3&gt;

&lt;p&gt;■ Always use a for loop rather than a for…in loop for iterating over the indexed properties of an array.&lt;/p&gt;

&lt;p&gt;■ Consider storing the length property of an array in a local vari- able before a loop to avoid recomputing the property lookup.&lt;/p&gt;

&lt;h3 id=&quot;item-50-prefer-iteration-methods-to-loops&quot;&gt;Item 50: Prefer Iteration Methods to Loops&lt;/h3&gt;

&lt;p&gt;✦ Use iteration methods such as Array.prototype.map in place of for loops to make code more read- able and avoid duplicating loop control logic.&lt;/p&gt;

&lt;p&gt;✦ Use custom iteration functions to abstract common loop patterns that are not provided by the standard library.&lt;/p&gt;

&lt;p&gt;✦ Traditional loops can still be appropriate in cases where early exit is necessary; alternatively, the some and every methods can be used for early exit.&lt;/p&gt;

&lt;h3 id=&quot;item-51-reuse-generic-array-methods-on-array-like-objects&quot;&gt;Item 51: Reuse Generic Array Methods on Array-Like Objects&lt;/h3&gt;

&lt;p&gt;✦ Reuse generic Array methods on array-like objects by extracting method objects and using their call method.&lt;/p&gt;

&lt;p&gt;✦ Any object can be used with generic Array methods if it has indexed properties and an appropriate length property.&lt;/p&gt;

&lt;h3 id=&quot;item-52-prefer-array-literals-to-the-array-constructor&quot;&gt;Item 52: Prefer Array Literals to the Array Constructor&lt;/h3&gt;

&lt;p&gt;✦ The Array constructor behaves differently if its first argument is a number.&lt;/p&gt;

&lt;p&gt;✦ Use array literals instead of the Array constructor.&lt;/p&gt;

&lt;h2 id=&quot;6---library-and-api-design&quot;&gt;6 - Library and API Design&lt;/h2&gt;

&lt;h3 id=&quot;item-53-maintain-consistent-conventions&quot;&gt;Item 53: Maintain Consistent Conventions&lt;/h3&gt;

&lt;p&gt;✦ Use consistent conventions for variable names and function signatures.&lt;/p&gt;

&lt;p&gt;✦ Don’t deviate from conventions your users are likely to encounter in other parts of their development platform.&lt;/p&gt;

&lt;h3 id=&quot;item-54-treat-undefined-as-no-value&quot;&gt;Item 54: Treat undefined As “No Value”&lt;/h3&gt;

&lt;p&gt;✦ Avoid using undefined to represent anything other than the absence of a specific value.&lt;/p&gt;

&lt;p&gt;✦ Use descriptive string values or objects with named boolean proper- ties, rather than undefined or null, to represent application-specific flags.&lt;/p&gt;

&lt;p&gt;✦ Test for undefined instead of checking arguments.length to provide parameter default values.&lt;/p&gt;

&lt;p&gt;✦ Never use truthiness tests for parameter default values that should allow 0, NaN, or the empty string as valid arguments.&lt;/p&gt;

&lt;h3 id=&quot;item-55-accept-options-objects-for-keyword-arguments&quot;&gt;Item 55: Accept Options Objects for Keyword Arguments&lt;/h3&gt;

&lt;p&gt;✦ Use options objects to make APIs more readable and memorable.&lt;/p&gt;

&lt;p&gt;✦ The arguments provided by an options object should all be treated as optional.&lt;/p&gt;

&lt;p&gt;✦ Use an extend utility function to abstract out the logic of extracting values from options objects.&lt;/p&gt;

&lt;h3 id=&quot;item-56-avoid-unnecessary-state&quot;&gt;Item 56: Avoid Unnecessary State&lt;/h3&gt;

&lt;p&gt;✦ Prefer stateless APIs where possible.&lt;/p&gt;

&lt;p&gt;✦ When providing stateful APIs, document the relevant state that each operation depends on.&lt;/p&gt;

&lt;h3 id=&quot;item-57-use-structural-typing-for-flexible-interfaces&quot;&gt;Item 57: Use Structural Typing for Flexible Interfaces&lt;/h3&gt;

&lt;p&gt;✦ Use structural typing (also known as duck typing) for flexible object interfaces.&lt;/p&gt;

&lt;p&gt;✦ Avoid inheritance when structural interfaces are more flexible and lightweight.&lt;/p&gt;

&lt;p&gt;✦ Use mock objects, that is, alternative implementations of interfaces that provide repeatable behavior, for unit testing.&lt;/p&gt;

&lt;h3 id=&quot;item-58-distinguish-between-array-and-array-like&quot;&gt;Item 58: Distinguish between Array and Array-Like&lt;/h3&gt;

&lt;p&gt;✦ Never overload structural types with other overlapping types.&lt;/p&gt;

&lt;p&gt;✦ When overloading a structural type with other types, test for the other types first.&lt;/p&gt;

&lt;p&gt;✦ Accept true arrays instead of array-like objects when overloading with other object types.&lt;/p&gt;

&lt;p&gt;✦ Document whether your API accepts true arrays or array-like values.&lt;/p&gt;

&lt;p&gt;✦ Use ES5’s Array.isArray to test for true arrays.&lt;/p&gt;

&lt;h3 id=&quot;item-59-avoid-excessive-coercion&quot;&gt;Item 59: Avoid Excessive Coercion&lt;/h3&gt;

&lt;p&gt;✦ Avoid mixing coercions with overloading.&lt;/p&gt;

&lt;p&gt;✦ Consider defensively guarding against unexpected inputs.&lt;/p&gt;

&lt;h3 id=&quot;item-60-support-method-chaining&quot;&gt;Item 60: Support Method Chaining&lt;/h3&gt;

&lt;p&gt;✦ Use method chaining to combine stateless operations.&lt;/p&gt;

&lt;p&gt;✦ Support method chaining by designing stateless methods that produce new objects.&lt;/p&gt;

&lt;p&gt;✦ Support method chaining in stateful methods by returning this.&lt;/p&gt;

&lt;h2 id=&quot;7---concurrency&quot;&gt;7 - Concurrency&lt;/h2&gt;

&lt;h3 id=&quot;item-61-dont-block-the-event-queue-on-io&quot;&gt;Item 61: Don’t Block the Event Queue on I/O&lt;/h3&gt;

&lt;p&gt;✦ Asynchronous APIs take callbacks to defer processing of expensive operations and avoid blocking the main application.&lt;/p&gt;

&lt;p&gt;✦ JavaScript accepts events concurrently but processes event handlers sequentially using an event queue.&lt;/p&gt;

&lt;p&gt;✦ Never use blocking I/O in an application’s event queue.&lt;/p&gt;

&lt;h3 id=&quot;item-62-use-nested-or-named-callbacks-for-asynchronous-sequencing&quot;&gt;Item 62: Use Nested or Named Callbacks for Asynchronous Sequencing&lt;/h3&gt;

&lt;p&gt;✦ Use nested or named callbacks to perform several asynchronous operations in sequence.&lt;/p&gt;

&lt;p&gt;✦ Try to strike a balance between excessive nesting of callbacks and awkward naming of non-nested callbacks.&lt;/p&gt;

&lt;p&gt;✦ Avoid sequencing operations that can be performed concurrently.&lt;/p&gt;

&lt;h3 id=&quot;item-63-be-aware-of-dropped-errors&quot;&gt;Item 63: Be Aware of Dropped Errors&lt;/h3&gt;

&lt;p&gt;✦ Avoid copying and pasting error-handling code by writing shared error-handling functions.&lt;/p&gt;

&lt;p&gt;✦ Make sure to handle all error conditions explicitly to avoid dropped errors.&lt;/p&gt;

&lt;h3 id=&quot;item-64-use-recursion-for-asynchronous-loops&quot;&gt;Item 64: Use Recursion for Asynchronous Loops&lt;/h3&gt;

&lt;p&gt;✦ Loops cannot be asynchronous.&lt;/p&gt;

&lt;p&gt;✦ Use recursive functions to perform iterations in separate turns of the event loop.&lt;/p&gt;

&lt;p&gt;✦ Recursion performed in separate turns of the event loop does not overflow the call stack.&lt;/p&gt;

&lt;h3 id=&quot;item-65-dont-block-the-event-queue-on-computation&quot;&gt;Item 65: Don’t Block the Event Queue on Computation&lt;/h3&gt;

&lt;p&gt;✦ Avoid expensive algorithms in the main event queue.&lt;/p&gt;

&lt;p&gt;✦ On platforms that support it, the Worker API can be used for running long computations in a separate event queue.&lt;/p&gt;

&lt;p&gt;✦ When the Worker API is not available or is too costly, consider break- ing up computations across multiple turns of the event loop.&lt;/p&gt;

&lt;h3 id=&quot;item-66-use-a-counter-to-perform-concurrent-operations&quot;&gt;Item 66: Use a Counter to Perform Concurrent Operations&lt;/h3&gt;

&lt;p&gt;✦ Events in a JavaScript application occur nondeterministically, that is, in unpredictable order.&lt;/p&gt;

&lt;p&gt;✦ Use a counter to avoid data races in concurrent operations.&lt;/p&gt;

&lt;h3 id=&quot;item-67-never-call-asynchronous-callbacks-synchronously&quot;&gt;Item 67: Never Call Asynchronous Callbacks Synchronously&lt;/h3&gt;

&lt;p&gt;✦ Never call an asynchronous callback synchronously, even if the data is immediately available.&lt;/p&gt;

&lt;p&gt;✦ Calling an asynchronous callback synchronously disrupts the expected sequence of operations and can lead to unexpected inter-leaving of code.&lt;/p&gt;

&lt;p&gt;✦ Calling an asynchronous callback synchronously can lead to stack overflows or mishandled exceptions.&lt;/p&gt;

&lt;p&gt;✦ Use an asynchronous API such as setTimeout to schedule an asyn- chronous callback to run in another turn.&lt;/p&gt;

&lt;h3 id=&quot;item-68-use-promises-for-cleaner-asynchronous-logic&quot;&gt;Item 68: Use Promises for Cleaner Asynchronous Logic&lt;/h3&gt;

&lt;p&gt;✦ Promises represent eventual values, that is, concurrent computations that eventually produce a result.&lt;/p&gt;

&lt;p&gt;✦ Use promises to compose different concurrent operations.&lt;/p&gt;

&lt;p&gt;✦ Use promise APIs to avoid data races.&lt;/p&gt;

&lt;p&gt;✦ Use select (also known as choose) for situations where an inten- tional race condition is required.&lt;/p&gt;

&lt;p&gt;————— 低调的配图分界线 —————&lt;/p&gt;

&lt;p&gt;✦ Effective JavaScript - Loi Wu -&lt;/p&gt;

&lt;div class=&quot;scale&quot;&gt;&lt;img src=&quot;img/timg10.jpg&quot; alt=&quot;Effective JavaScript&quot; /&gt;&lt;/div&gt;

</description>
            <pubDate>Sun, 07 Oct 2018 23:00:00 +0800</pubDate>
            <link>http://localhost:4000/#/2018/10/07/effective-javascript.html</link>
            <guid isPermaLink="true">http://localhost:4000/#/2018/10/07/effective-javascript.html</guid>
            
            
        </item>
        
        <item>
            <title>roundchow</title>
            <description>&lt;h3 id=&quot;roundchow&quot;&gt;roundchow&lt;/h3&gt;

&lt;p&gt;如果你好奇谁是roundchow，以后你会知道的&lt;/p&gt;

</description>
            <pubDate>Fri, 05 Oct 2018 03:00:00 +0800</pubDate>
            <link>http://localhost:4000/#/2018/10/05/roundchow.html</link>
            <guid isPermaLink="true">http://localhost:4000/#/2018/10/05/roundchow.html</guid>
            
            
        </item>
        
    </channel>
</rss>
