<p>Effective JavaScript</p>

<h2 id="1---accustoming-yourself-to-javascript">1 - Accustoming Yourself to JavaScript</h2>

<h3 id="item-1-know-which-javascript-you-are-using">Item 1: Know Which JavaScript You Are Using</h3>

<p>✦ Decide which versions of JavaScript your application supports.</p>

<p>✦ Be sure that any JavaScript features you use are supported by all environments where your application runs.</p>

<p>✦ Always test strict code in environments that perform the strict-mode checks.</p>

<p>✦ Beware of concatenating scripts that differ in their expectations about strict mode.</p>

<h3 id="item-2-understand-javascripts-floating-point-numbers">Item 2: Understand JavaScript’s Floating-Point Numbers</h3>

<p>✦ JavaScript numbers are double-precision floating-point numbers.</p>

<p>✦ Integers in JavaScript are just a subset of doubles rather than a separate datatype.</p>

<p>✦ Bitwise operators treat numbers as if they were 32-bit signed integers.</p>

<p>✦ Be aware of limitations of precisions in flaoting-point arithmetic.</p>

<h3 id="item-3-beware-of-implicit-coercions">Item 3: Beware of Implicit Coercions</h3>

<p>✦ Type errors can be silently hidden by implicit coercions.</p>

<p>✦ The + operator is overloaded to do addition or string concatenation depending on its argument types.</p>

<p>✦ Objects are coerced to numbers via valueOf and to strings via toString.</p>

<p>✦ Objects with valueOf methods should implement a toString method taht provides a string representation of the number produced by valueOf.</p>

<p>✦ Use typeof or comparison to undefined rather than truthiness to test for undefined values.</p>

<h3 id="item-4-prefer-primitives-to-object-wrappers">Item 4: Prefer Primitives to Object Wrappers</h3>

<p>✦ Object wrappers for primitive types do not have the same behavior as their primitive calues when compared for equality.</p>

<p>✦ Getting and setting properties on primitives implicitly creates object wrappers.</p>

<h3 id="item-5-avoid-using--with-mixed-types">Item 5: Avoid using == with Mixed Types</h3>

<p>✦ The == operator applies a confusing set of implicit coercoins when its arguments are of different types.</p>

<p>✦ Use === to make it clear to your readers that your comparison does not involve any implicit coercions.</p>

<p>✦ Use your own explicit coercions when comparing values of different types to make your program’s behavior clearer.</p>

<h3 id="item-6-learn-the-limits-of-semicolon-insertion">Item 6: Learn the Limits of Semicolon Insertion</h3>

<p>✦ Semicolons are only ever inferred before a }, at the end of a line, or at the end of a program.</p>

<p>✦ Semicolons are only ever inffered when the next token cannot be parsed.</p>

<p>✦ Never omit a semicolon before a statement beginning with (, [, +, -, or /.</p>

<p>✦ When concatenating scripts, insert semicolons explicitly between scripts.</p>

<p>✦ Never put a newline before the argument to return, throw, break, continue, ++, or –.</p>

<p>✦ Semicolons are never inferred as separators in the head of a for loop or as empty statements.</p>

<h3 id="item-7-think-of-strings-as-sequences-of-16-bit-code-units">Item 7: Think of Strings As Sequences of 16-Bit Code Units</h3>

<p>✦ JavaScript strings consist of 16-bit code units, not Unicode code points.</p>

<p>✦ Unicode code points 2^16 and above are represented in JavaScript by two code units, known as a surrogate pair.</p>

<p>✦ Surrogate pairs throw off string element counts, affecting length, charAt, charCodeAt, and regular expression patterns such as “.”.</p>

<p>✦ Use third-party libraries for writing code point-aware string manipulation.</p>

<p>✦ Whenever you are using a library that works with strings, consult the documentation to see how it handles the full range of code points.</p>

<h2 id="2---variable-scope">2 - Variable Scope</h2>

<h3 id="item-8-minimize-use-of-the-global-object">Item 8: Minimize Use of the Global Object</h3>

<p>✦ Avoid declaring global variables.</p>

<p>✦ Declare variables as locally as possible.</p>

<p>✦ Avoid adding properties to the global object.</p>

<p>✦ Use the global object for platform feature detection.</p>

<h3 id="item-9-always-declare-local-variables">Item 9: Always Declare Local Variables</h3>

<p>✦ Always declare new local variables with var.</p>

<p>✦ Consider using lint tools to help check for unbound variables.</p>

<h3 id="item-10-avoid-with">Item 10: Avoid with</h3>

<p>✦ Avoid using with statements.</p>

<p>✦ Use short variable names for repeated access to an object.</p>

<p>✦ Explicitly bind local variables to object properties instead of implicitly binding them with a with statement.</p>

<h3 id="item-11-get-comfortable-with-closures">Item 11: Get Comfortable with Closures</h3>

<p>✦ Functions can refer to variables defined in outer scopes.</p>

<p>✦ Closures can outlive the function that creates them.</p>

<p>✦ Closures internally store references to their outer variables, and can both read and update their stored variables.</p>

<h3 id="item-12-understand-variable-hoisting">Item 12: Understand Variable Hoisting</h3>

<p>✦ Variable declarations within a block are implicitly hoisted to the top of their enclosing function.</p>

<p>✦ Redeclarations of a variable are treated as a single variable.</p>

<p>✦ Consider manually hoisting local variable declarations to avoid confusion.</p>

<h3 id="item-13-use-immediately-invoked-function-expressions-to-create-local-scopes">Item 13: Use Immediately Invoked Function Expressions to Create Local Scopes</h3>

<p>✦ Understand the difference between binding and assignment.</p>

<p>✦ Closures capture their outer variables by reference, not by value.</p>

<p>✦ Use immediately invoked function expressions (IIFEs) to create local scopes.</p>

<p>✦ Be aware of the cases where wrapping a block in an IIFE can change its behavior.</p>

<h3 id="item-14-beware-of-unportable-scoping-of-named-function-expressions">Item 14: Beware of Unportable Scoping of Named Function Expressions</h3>

<p>✦ Use named function expressions to improve stack traces in Error objects and debuggers.</p>

<p>✦ Beware of pollution of function expression scope with Object .prototype in ES3 and buggy JavaScript environments.</p>

<p>✦ Beware of hoisting and duplicate allocation of named function expressions in buggy JavaScript environments.</p>

<p>✦ Consider avoiding named function expressions or removing them before shipping.</p>

<p>✦ If you are shipping in properly implemented ES5 environments, you’ve got nothing to worry about.</p>

<h3 id="item-15-beware-of-unportable-scoping-of-block-local-function-declarations">Item 15: Beware of Unportable Scoping of Block-Local Function Declarations</h3>

<p>✦ Always keep function declarations at the outermost level of a program or a containing function to avoid unportable behavior.</p>

<p>✦ Use var declarations with conditional assignment instead of conditional function declarations.</p>

<h3 id="item-16-avoid-creating-local-variables-with-eval">Item 16: Avoid Creating Local Variables with eval</h3>

<p>✦ Avoid creating variables with eval that pollute the caller’s scope.</p>

<p>✦ If eval code might create global variables, wrap the call in a nested function to prevent scope pollution.</p>

<h3 id="item-17-prefer-indirect-eval-to-direct-eval">Item 17: Prefer Indirect eval to Direct eval</h3>

<p>✦ Wrap eval in a sequence expression with a useless literal to force the use of indirect eval.</p>

<p>✦ Prefer indirect eval to direct eval whenever possible.</p>

<h2 id="3---working-with-functions">3 - Working with Functions</h2>

<h3 id="item-18-understand-the-difference-between-function-method-and-constructor-calls">Item 18: Understand the Difference between Function, Method, and Constructor Calls</h3>

<p>✦ Method calls provide the object in which the method property is looked up as their receiver.</p>

<p>✦ Function calls provide the global object (or undefined for strict func- tions) as their receiver. Calling methods with function call syntax is rarely useful.</p>

<p>✦ Constructors are called with new and receive a fresh object as their receiver.</p>

<h3 id="item-19-get-comfortable-using-higher-order-functions">Item 19: Get Comfortable Using Higher-Order Functions</h3>

<p>✦ Higher-order functions are functions that take other functions as arguments or return functions as their result.</p>

<p>✦ Familiarize yourself with higher-order functions in existing libraries.</p>

<p>✦ Learn to detect common coding patterns that can be replaced by higher-order functions.</p>

<h3 id="item-20-use-call-to-call-methods-with-a-custom-receiver">Item 20: Use call to Call Methods with a Custom Receiver</h3>

<p>✦ Use the call method to call a function with a custom receiver.</p>

<p>✦ Use the call method for calling methods that may not exist on a given object.</p>

<p>✦ Use the call method for defining higher-order functions that allow clients to provide a receiver for the callback.</p>

<h3 id="item-21-use-apply-to-call-functions-with-different-numbers-of-arguments">Item 21: Use apply to Call Functions with Different Numbers of Arguments</h3>

<p>✦ Use the apply method to call variadic functions with a computed array of arguments.</p>

<p>✦ Use the first argument of apply to provide a receiver for variadic methods.</p>

<h3 id="item-22-use-arguments-to-create-variadic-functions">Item 22: Use arguments to Create Variadic Functions</h3>

<p>✦ Use the implicit arguments object to implement variable-arity functions.</p>

<p>✦ Consider providing additional fixed-arity versions of the variadic functions you provide so that your consumers don’t need to use the apply method.</p>

<h3 id="item-23-never-modify-the-arguments-object">Item 23: Never Modify the arguments Object</h3>

<p>✦ Never modify the arguments object.</p>

<p>✦ Copy the arguments object to a real array using [].slice.call(arguments) before modifying it.</p>

<h3 id="item-24-use-a-variable-to-save-a-reference-to-arguments">Item 24: Use a Variable to Save a Reference to arguments</h3>

<p>✦ Be aware of the function nesting level when referring to arguments.</p>

<p>✦ Bind an explicitly scoped reference to arguments in order to refer to it from nested functions.</p>

<h3 id="item-25-use-bind-to-extract-methods-with-a-fixed-receiver">Item 25: Use bind to Extract Methods with a Fixed Receiver</h3>

<p>✦ Beware that extracting a method does not bind the method’s receiver to its object.</p>

<p>✦ When passing an object’s method to a higher-order function, use an anonymous function to call the method on the appropriate receiver.</p>

<p>✦ Use bind as a shorthand for creating a function bound to the appropriate receiver.</p>

<h3 id="item-26-use-bind-to-curry-functions">Item 26: Use bind to Curry Functions</h3>

<p>✦ Use bind to curry a function, that is, to create a delegating function with a fixed subset of the required arguments.</p>

<p>✦ Pass null or undefined as the receiver argument to curry a function that ignores its receiver.</p>

<h3 id="item-27-prefer-closures-to-strings-for-encapsulating-code">Item 27: Prefer Closures to Strings for Encapsulating Code</h3>

<p>✦ Never include local references in strings when sending them to APIs that execute them with eval.</p>

<p>✦ Prefer APIs that accept functions to call rather than strings to eval.</p>

<h3 id="item-28-avoid-relying-on-the-tostring-method-of-functions">Item 28: Avoid Relying on the toString Method of Functions</h3>

<p>✦ JavaScript engines are not required to produce accurate reflections of function source code via toString.</p>

<p>✦ Never rely on precise details of function source, since different engines may produce different results from toString.</p>

<p>✦ The results of toString do not expose the values of local variables stored in a closure.</p>

<p>✦ In general, avoid using toString on functions.</p>

<h3 id="item-29-avoid-nonstandard-stack-inspection-properties">Item 29: Avoid Nonstandard Stack Inspection Properties</h3>

<p>✦ Avoid the nonstandard arguments.caller and arguments.callee, because they are not reliably portable.</p>

<p>✦ Avoid the nonstandard caller property of functions, because it does not reliably contain complete information about the stack.</p>

<h2 id="4---objects-and-prototypes">4 - Objects and Prototypes</h2>

<h3 id="item-30-understand-the-difference-between-prototype-getprototypeof-and__proto__">Item 30: Understand the Difference between prototype, getPrototypeOf, and__proto__</h3>

<p>✦ C.prototype determines the prototype of objects created by new C().</p>

<p>✦ Object.getPrototypeOf(obj) is the standard ES5 function for retrieving the prototype of an object.</p>

<p>✦ obj.<strong>proto</strong> is a nonstandard mechanism for retrieving the proto- type of an object.</p>

<p>✦ A class is a design pattern consisting of a constructor function and an associated prototype.</p>

<h3 id="item-31-prefer-objectgetprototypeof-to-proto">Item 31: Prefer Object.getPrototypeOf to <strong>proto</strong></h3>

<p>✦ Prefer the standards-compliant Object.getPrototypeOf to the non- standard <strong>proto</strong> property.</p>

<p>✦ Implement Object.getPrototypeOf in non-ES5 environments that support <strong>proto</strong>.</p>

<h3 id="item-32-never-modify-proto">Item 32: Never Modify <strong>proto</strong></h3>

<p>✦ Never modify an object’s <strong>proto</strong> property.</p>

<p>✦ Use Object.create to provide a custom prototype for new objects.</p>

<h3 id="item-33-make-your-constructors-new-agnostic">Item 33: Make Your Constructors new-Agnostic</h3>

<p>✦ Make a constructor agnostic to its caller’s syntax by reinvoking itself with new or with Object.create.</p>

<p>✦ Document clearly when a function expects to be called with new.</p>

<h3 id="item-34-store-methods-on-prototypes">Item 34: Store Methods on Prototypes</h3>

<p>✦ Storing methods on instance objects creates multiple copies of the functions, one per instance object.</p>

<p>✦ Prefer storing methods on prototypes over storing them on instance objects.</p>

<h3 id="item-35-use-closures-to-store-private-data">Item 35: Use Closures to Store Private Data</h3>

<p>✦ Closure variables are private, accessible only to local references.</p>

<p>✦ Use local variables as private data to enforce information hiding within methods.</p>

<h3 id="item-36-store-instance-state-only-on-instance-objects">Item 36: Store Instance State Only on Instance Objects</h3>

<p>✦ Mutable data can be problematic when shared, and prototypes are shared between all their instances.</p>

<p>✦ Store mutable per-instance state on instance objects.</p>

<h3 id="item-37-recognize-the-implicit-binding-of-this">Item 37: Recognize the Implicit Binding of this</h3>

<p>✦ The scope of this is always determined by its nearest enclosing function.</p>

<p>✦ Use a local variable, usually called self, me, or that, to make a this-binding available to inner functions.</p>

<h3 id="item-38-call-superclass-constructors-from-subclass-constructors">Item 38: Call Superclass Constructors from Subclass Constructors</h3>

<p>✦ Call the superclass constructor explicitly from subclass construc- tors, passing this as the explicit receiver.</p>

<p>✦ Use Object.create to construct the subclass prototype object to avoid calling the superclass constructor.</p>

<h3 id="item-39-never-reuse-superclass-property-names">Item 39: Never Reuse Superclass Property Names</h3>

<p>✦ Be aware of all property names used by your superclasses.</p>

<p>✦ Never reuse a superclass property name in a subclass.</p>

<h3 id="item-40-avoid-inheriting-from-standard-classes">Item 40: Avoid Inheriting from Standard Classes</h3>

<p>✦ Inheriting from standard classes tends to break due to special internal properties such as [[Class]].</p>

<p>✦ Prefer delegating to properties instead of inheriting from standard classes.</p>

<h3 id="item-41-treat-prototypes-as-an-implementation-detail">Item 41: Treat Prototypes As an Implementation Detail</h3>

<p>✦ Objects are interfaces; prototypes are implementations.</p>

<p>✦ Avoid inspecting the prototype structure of objects you don’t control.</p>

<p>✦ Avoid inspecting properties that implement the internals of objects you don’t control.</p>

<h3 id="item-42-avoid-reckless-monkey-patching">Item 42: Avoid Reckless Monkey-Patching</h3>

<p>✦ Avoid reckless monkey-patching.</p>

<p>✦ Document any monkey-patching performed by a library.</p>

<p>✦ Consider making monkey-patching optional by performing the mod- ifications in an exported function.</p>

<p>✦ Use monkey-patching to provide polyfills for missing standard APIs.</p>

<h2 id="5---arrays-and-dictionaries">5 - Arrays and Dictionaries</h2>

<h3 id="item-43-build-lightweight-dictionaries-from-direct-instances-of-object">Item 43: Build Lightweight Dictionaries from Direct Instances of Object</h3>

<p>✦ Use object literals to construct lightweight dictionaries.</p>

<p>✦ Lightweight dictionaries should be direct descendants of Object.prototype to protect against prototype pollution in for…in loops.</p>

<h3 id="item-44-use-null-prototypes-to-prevent-prototype-pollution">Item 44: Use null Prototypes to Prevent Prototype Pollution</h3>

<p>✦ In ES5, use Object.create(null) to create prototype-free empty objects that are less susceptible to pollution.</p>

<p>✦ In older environments, consider using { <strong>proto</strong>: null }.</p>

<p>✦ But beware that <strong>proto</strong> is neither standard nor entirely portable and may be removed in future JavaScript environments.</p>

<p>✦ Never use the name “<strong>proto</strong>” as a dictionary key since some environments treat this property specially.</p>

<h3 id="item-45-use-hasownproperty-to-protect-against-prototype-pollution">Item 45: Use hasOwnProperty to Protect Against Prototype Pollution</h3>

<p>✦ Use hasOwnProperty to protect against prototype pollution.</p>

<p>✦ Use lexical scope and call to protect against overriding of the hasOwnProperty method.</p>

<p>✦ Consider implementing dictionary operations in a class that encapsulates the boilerplate hasOwnProperty tests.</p>

<p>✦ Use a dictionary class to protect against the use of “<strong>proto</strong>” as a key.</p>

<h3 id="item-46-prefer-arrays-to-dictionaries-for-ordered-collections">Item 46: Prefer Arrays to Dictionaries for Ordered Collections</h3>

<p>✦ Avoid relying on the order in which for…in loops enumerate object properties.</p>

<p>✦ If you aggregate data in a dictionary, make sure the aggregate oper- ations are order-insensitive.</p>

<p>✦ Use arrays instead of dictionary objects for ordered collections.</p>

<h3 id="item-47-never-add-enumerable-properties-to-objectprototype">Item 47: Never Add Enumerable Properties to Object.prototype</h3>

<p>✦ Avoid adding properties to Object.prototype.</p>

<p>✦ Consider writing a function instead of an Object.prototype method.</p>

<p>✦ If you do add properties to Object.prototype, use ES5’s Object.defineProperty to define them as nonenumerable properties.</p>

<h3 id="item-48-avoid-modifying-an-object-during-enumeration">Item 48: Avoid Modifying an Object during Enumeration</h3>

<p>✦ Make sure not to modify an object while enumerating its properties with a for…in loop.</p>

<p>✦ Use a while loop or classic for loop instead of a for…in loop when iterating over an object whose contents might change during the loop.</p>

<p>✦ For predictable enumeration over a changing data structure, con- sider using a sequential data structure such as an array instead of a dictionary object.</p>

<h3 id="item-49-prefer-for-loops-to-forin-loops-for-array-iteration">Item 49: Prefer for Loops to for…in Loops for Array Iteration</h3>

<p>■ Always use a for loop rather than a for…in loop for iterating over the indexed properties of an array.</p>

<p>■ Consider storing the length property of an array in a local vari- able before a loop to avoid recomputing the property lookup.</p>

<h3 id="item-50-prefer-iteration-methods-to-loops">Item 50: Prefer Iteration Methods to Loops</h3>

<p>✦ Use iteration methods such as Array.prototype.map in place of for loops to make code more read- able and avoid duplicating loop control logic.</p>

<p>✦ Use custom iteration functions to abstract common loop patterns that are not provided by the standard library.</p>

<p>✦ Traditional loops can still be appropriate in cases where early exit is necessary; alternatively, the some and every methods can be used for early exit.</p>

<h3 id="item-51-reuse-generic-array-methods-on-array-like-objects">Item 51: Reuse Generic Array Methods on Array-Like Objects</h3>

<p>✦ Reuse generic Array methods on array-like objects by extracting method objects and using their call method.</p>

<p>✦ Any object can be used with generic Array methods if it has indexed properties and an appropriate length property.</p>

<h3 id="item-52-prefer-array-literals-to-the-array-constructor">Item 52: Prefer Array Literals to the Array Constructor</h3>

<p>✦ The Array constructor behaves differently if its first argument is a number.</p>

<p>✦ Use array literals instead of the Array constructor.</p>

<h2 id="6---library-and-api-design">6 - Library and API Design</h2>

<h3 id="item-53-maintain-consistent-conventions">Item 53: Maintain Consistent Conventions</h3>

<p>✦ Use consistent conventions for variable names and function signatures.</p>

<p>✦ Don’t deviate from conventions your users are likely to encounter in other parts of their development platform.</p>

<h3 id="item-54-treat-undefined-as-no-value">Item 54: Treat undefined As “No Value”</h3>

<p>✦ Avoid using undefined to represent anything other than the absence of a specific value.</p>

<p>✦ Use descriptive string values or objects with named boolean proper- ties, rather than undefined or null, to represent application-specific flags.</p>

<p>✦ Test for undefined instead of checking arguments.length to provide parameter default values.</p>

<p>✦ Never use truthiness tests for parameter default values that should allow 0, NaN, or the empty string as valid arguments.</p>

<h3 id="item-55-accept-options-objects-for-keyword-arguments">Item 55: Accept Options Objects for Keyword Arguments</h3>

<p>✦ Use options objects to make APIs more readable and memorable.</p>

<p>✦ The arguments provided by an options object should all be treated as optional.</p>

<p>✦ Use an extend utility function to abstract out the logic of extracting values from options objects.</p>

<h3 id="item-56-avoid-unnecessary-state">Item 56: Avoid Unnecessary State</h3>

<p>✦ Prefer stateless APIs where possible.</p>

<p>✦ When providing stateful APIs, document the relevant state that each operation depends on.</p>

<h3 id="item-57-use-structural-typing-for-flexible-interfaces">Item 57: Use Structural Typing for Flexible Interfaces</h3>

<p>✦ Use structural typing (also known as duck typing) for flexible object interfaces.</p>

<p>✦ Avoid inheritance when structural interfaces are more flexible and lightweight.</p>

<p>✦ Use mock objects, that is, alternative implementations of interfaces that provide repeatable behavior, for unit testing.</p>

<h3 id="item-58-distinguish-between-array-and-array-like">Item 58: Distinguish between Array and Array-Like</h3>

<p>✦ Never overload structural types with other overlapping types.</p>

<p>✦ When overloading a structural type with other types, test for the other types first.</p>

<p>✦ Accept true arrays instead of array-like objects when overloading with other object types.</p>

<p>✦ Document whether your API accepts true arrays or array-like values.</p>

<p>✦ Use ES5’s Array.isArray to test for true arrays.</p>

<h3 id="item-59-avoid-excessive-coercion">Item 59: Avoid Excessive Coercion</h3>

<p>✦ Avoid mixing coercions with overloading.</p>

<p>✦ Consider defensively guarding against unexpected inputs.</p>

<h3 id="item-60-support-method-chaining">Item 60: Support Method Chaining</h3>

<p>✦ Use method chaining to combine stateless operations.</p>

<p>✦ Support method chaining by designing stateless methods that produce new objects.</p>

<p>✦ Support method chaining in stateful methods by returning this.</p>

<h2 id="7---concurrency">7 - Concurrency</h2>

<h3 id="item-61-dont-block-the-event-queue-on-io">Item 61: Don’t Block the Event Queue on I/O</h3>

<p>✦ Asynchronous APIs take callbacks to defer processing of expensive operations and avoid blocking the main application.</p>

<p>✦ JavaScript accepts events concurrently but processes event handlers sequentially using an event queue.</p>

<p>✦ Never use blocking I/O in an application’s event queue.</p>

<h3 id="item-62-use-nested-or-named-callbacks-for-asynchronous-sequencing">Item 62: Use Nested or Named Callbacks for Asynchronous Sequencing</h3>

<p>✦ Use nested or named callbacks to perform several asynchronous operations in sequence.</p>

<p>✦ Try to strike a balance between excessive nesting of callbacks and awkward naming of non-nested callbacks.</p>

<p>✦ Avoid sequencing operations that can be performed concurrently.</p>

<h3 id="item-63-be-aware-of-dropped-errors">Item 63: Be Aware of Dropped Errors</h3>

<p>✦ Avoid copying and pasting error-handling code by writing shared error-handling functions.</p>

<p>✦ Make sure to handle all error conditions explicitly to avoid dropped errors.</p>

<h3 id="item-64-use-recursion-for-asynchronous-loops">Item 64: Use Recursion for Asynchronous Loops</h3>

<p>✦ Loops cannot be asynchronous.</p>

<p>✦ Use recursive functions to perform iterations in separate turns of the event loop.</p>

<p>✦ Recursion performed in separate turns of the event loop does not overflow the call stack.</p>

<h3 id="item-65-dont-block-the-event-queue-on-computation">Item 65: Don’t Block the Event Queue on Computation</h3>

<p>✦ Avoid expensive algorithms in the main event queue.</p>

<p>✦ On platforms that support it, the Worker API can be used for running long computations in a separate event queue.</p>

<p>✦ When the Worker API is not available or is too costly, consider break- ing up computations across multiple turns of the event loop.</p>

<h3 id="item-66-use-a-counter-to-perform-concurrent-operations">Item 66: Use a Counter to Perform Concurrent Operations</h3>

<p>✦ Events in a JavaScript application occur nondeterministically, that is, in unpredictable order.</p>

<p>✦ Use a counter to avoid data races in concurrent operations.</p>

<h3 id="item-67-never-call-asynchronous-callbacks-synchronously">Item 67: Never Call Asynchronous Callbacks Synchronously</h3>

<p>✦ Never call an asynchronous callback synchronously, even if the data is immediately available.</p>

<p>✦ Calling an asynchronous callback synchronously disrupts the expected sequence of operations and can lead to unexpected inter-leaving of code.</p>

<p>✦ Calling an asynchronous callback synchronously can lead to stack overflows or mishandled exceptions.</p>

<p>✦ Use an asynchronous API such as setTimeout to schedule an asyn- chronous callback to run in another turn.</p>

<h3 id="item-68-use-promises-for-cleaner-asynchronous-logic">Item 68: Use Promises for Cleaner Asynchronous Logic</h3>

<p>✦ Promises represent eventual values, that is, concurrent computations that eventually produce a result.</p>

<p>✦ Use promises to compose different concurrent operations.</p>

<p>✦ Use promise APIs to avoid data races.</p>

<p>✦ Use select (also known as choose) for situations where an inten- tional race condition is required.</p>

<p>————— 低调的配图分界线 —————</p>

<p>✦ Effective JavaScript - Loi Wu -</p>

<div class="scale"><img src="img/timg10.jpg" alt="Effective JavaScript" /></div>

